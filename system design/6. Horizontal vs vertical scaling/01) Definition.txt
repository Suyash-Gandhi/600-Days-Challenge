

## 6. Horizontal vs Vertical Scaling

Scaling is about handling more load (users, requests, data) as your system grows.
There are two fundamental ways to do this.

---

## 1. Vertical Scaling (Scale Up)

### What it means

You increase the power of a single machine.

You take one server and:

 Add more CPU
 Add more RAM
 Add faster storage

Same server → stronger server.

---

### Simple example

You have:

 1 server with 4 CPU, 8 GB RAM
 It starts slowing down

You upgrade it to:

 16 CPU, 64 GB RAM

No architecture change. Just a bigger machine.

---

### Where vertical scaling fits well

 Early-stage projects
 Small applications
 Databases that are hard to distribute
 Internal tools

---

### Advantages

 Very simple
 No major code changes
 Easy to maintain
 Low operational complexity

---

### Limitations

 Hard limit (a machine can’t grow forever)
 Single Point of Failure (if it dies → system is down)
 Downtime often required for upgrades
 Expensive at higher levels

---

### Real-world analogy

Upgrading your laptop:

 Add RAM
 Change CPU
  Still one machine.

---

## 2. Horizontal Scaling (Scale Out)

### What it means

You add more machines instead of making one machine bigger.

Multiple servers work together behind a load balancer.

---

### Simple example

Instead of:

 1 powerful server

You use:

 10 normal servers
 Traffic is distributed among them

If load increases → add more servers.

---

### Where horizontal scaling fits best

 High-traffic systems
 Web applications
 Microservices
 Cloud-native systems

---

### Advantages

 Practically unlimited growth
 Better fault tolerance
 No downtime while scaling
 Cheaper per unit at scale

---

### Limitations

 More complex architecture
 Requires stateless services
 Needs load balancers, service discovery
 Debugging becomes harder

---

### Real-world analogy

Hiring more workers instead of making one worker work faster.

---

## 3. Side-by-side Comparison

| Aspect            | Vertical Scaling   | Horizontal Scaling |
| ----------------- | ------------------ | ------------------ |
| Method            | Upgrade one server | Add more servers   |
| Complexity        | Low                | High               |
| Scalability limit | Fixed              | Very high          |
| Fault tolerance   | Poor               | Strong             |
| Cost pattern      | Steep              | Gradual            |
| Downtime          | Often required     | Usually none       |

---

## 4. How modern systems actually scale (important)

Most real systems combine both:

 Vertical scaling first (simpler)
 Then horizontal scaling when limits are hit

Example:

 Start with a bigger EC2 instance
 Later add load balancer + multiple instances

---

## 5. Common system design mistakes

 Trying horizontal scaling too early
 Scaling stateless services but forgetting the database
 Ignoring SPOF in vertically scaled systems
 Not designing for statelessness from day one

---

## 6. Interview-level intuition (keep this in mind)

 Vertical scaling = quick, simple, limited
 Horizontal scaling = complex, powerful, long-term

If traffic is predictable and small → vertical
If traffic is unpredictable and large → horizontal

---

