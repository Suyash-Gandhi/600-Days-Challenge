

 Ultimate System Design Roadmap (150 Topics)

---

 1. Fundamentals (Junior → Early Intermediate)

1. What is system design & why it matters
2. Functional vs non-functional requirements
3. Monolith vs microservices architecture
4. Latency vs throughput
5. Consistency vs availability (CAP theorem)
6. Horizontal vs vertical scaling
7. Stateless vs stateful services
8. Load testing, stress testing, benchmarking
9. Single point of failure (SPOF)
10. High availability (HA) basics
11. Threading vs multiprocessing basics
12. Async I/O vs multithreading vs multiprocessing trade-offs
13. Basics of containerization (Docker)

---

 2. Networking Basics

14. HTTP/HTTPS fundamentals
15. REST vs gRPC vs GraphQL
16. WebSockets & long polling
17. DNS resolution
18. CDN basics & edge caching
19. TCP vs UDP trade-offs
20. API gateways
21. Reverse proxies
22. Forward proxies
23. Nginx/HAProxy basics
24. TLS termination at load balancer vs app server
25. Multi-region networking & latency considerations

---

 3. Storage & Databases

26. Relational databases (MySQL, PostgreSQL)
27. NoSQL databases (MongoDB, Cassandra, DynamoDB)
28. Column vs document vs key-value stores
29. Database indexing (B-tree, hash, bitmap)
30. Database sharding strategies
31. Database replication (master-slave, leader-follower)
32. Strong vs eventual consistency
33. ACID vs BASE properties
34. CAP theorem applications in DBs
35. SQL vs NoSQL trade-offs
36. OLTP vs OLAP systems
37. Data lakes vs data warehouses (Snowflake, BigQuery)
38. Materialized views & denormalization strategies
39. Time-series databases (InfluxDB, TimescaleDB)
40. Graph databases (Neo4j, Amazon Neptune)

---

 4. Caching & Performance

41. What caching is & why it’s used
42. Client-side caching (browser, CDN)
43. Server-side caching (Redis, Memcached)
44. Write-through, write-around, write-back caching
45. Cache eviction policies (LRU, LFU, FIFO)
46. Cache invalidation strategies
47. CDN edge caching vs origin caching
48. Hotspot problem in caching
49. Bloom filters & use cases
50. Rate limiting with caching
51. Distributed cache consistency (Redis Cluster, Hazelcast)
52. Write amplification & read amplification issues
53. Performance profiling & tracing in microservices

---

 5. Message Queues & Streaming

54. Message queues basics (Kafka, RabbitMQ, SQS)
55. Publish-subscribe pattern
56. At-most-once, at-least-once, exactly-once delivery
57. Dead-letter queues
58. Event-driven architecture
59. Kafka partitions & offsets
60. Consumer groups & scaling consumers
61. Stream processing basics (Flink, Spark, Kinesis)
62. Event sourcing
63. CQRS (Command Query Responsibility Segregation)
64. Event replay & reprocessing
65. Event storming (system modeling technique)
66. Lambda architecture (batch + stream + serving layer)

---

 6. Scalability & Reliability

67. Load balancing (round robin, least connections)
68. Global load balancers (GeoDNS, Anycast)
69. Rate limiting strategies
70. Circuit breakers & retries
71. Service discovery (Consul, Eureka)
72. Heartbeat & health checks
73. Leader election algorithms (Raft, Paxos)
74. Failover strategies
75. Consensus protocols in distributed systems
76. Quorum-based writes/reads
77. Auto-healing systems (self-recovery, auto-restart strategies)
78. Autoscaling groups in cloud providers
79. Serverless scaling (AWS Lambda, Cloud Functions)
80. Multi-cloud vs hybrid cloud considerations

---

 7. Distributed Systems Concepts

81. Distributed transactions (2PC, 3PC)
82. Distributed locks (Zookeeper, Redis Redlock)
83. Idempotency in APIs
84. Clock synchronization (NTP, Lamport timestamps)
85. Vector clocks
86. Gossip protocol
87. Partition tolerance in practice
88. Data replication strategies (sync vs async)
89. CAP theorem real-world examples (DynamoDB, Cassandra)
90. Consistent hashing
91. Quorum vs leader-based replication trade-offs
92. Handling network partitions in practice
93. Design patterns for distributed systems (Saga, Choreography)

---

 8. Security & Authentication

94. HTTPS & TLS handshake
95. OAuth 2.0 & OpenID Connect
96. JWT authentication
97. API keys & HMAC signatures
98. Role-based access control (RBAC)
99. Attribute-based access control (ABAC)
100. Rate limiting for security (DoS protection)
101. CSRF protection
102. XSS prevention
103. SQL injection prevention
104. Secrets management (Vault, KMS)
105. Zero trust architecture
106. DDoS mitigation strategies (rate-limiting, WAFs, CDNs)
107. GDPR/CCPA compliance considerations

---

 9. Monitoring & Observability

108. Logging best practices (structured logs)
109. Metrics & time-series databases (Prometheus)
110. Distributed tracing (Jaeger, Zipkin)
111. Centralized log management (ELK stack)
112. SLOs, SLIs, SLAs
113. Alerting & incident response (PagerDuty)
114. Error budgets in reliability engineering
115. Canary releases
116. Blue-green deployments
117. Chaos engineering basics
118. Synthetic monitoring vs real-user monitoring
119. Observability-driven system design

---

 10. Advanced System Design (Senior Level)

120. Designing a URL shortener (Bitly)
121. Designing a rate limiter
122. Designing a social media feed (Twitter/FB)
123. Designing a chat/messaging app (WhatsApp)
124. Designing a video streaming service (YouTube/Netflix)
125. Designing an e-commerce system (Amazon-like)
126. Designing a ride-hailing service (Uber, Lyft)
127. Designing a distributed search engine (Google-lite)
128. Designing a payment system (Stripe, PayPal)
129. Designing large-scale microservices orchestration (Kubernetes-level)
130. Designing a notification system (email, push, SMS)
131. Designing a recommendation system (collaborative filtering, ML-lite)
132. Designing an analytics pipeline (tracking events at scale)
133. Designing multi-tenant SaaS systems
134. Designing systems with regulatory constraints (HIPAA, PCI-DSS)
135. Designing for eventual consistency vs strong consistency trade-offs
136. Designing for high-throughput ingestion (IoT, logs, telemetry)
137. Designing globally distributed systems (multi-region)
138. Designing systems for low-latency read/write operations
139. Designing systems for A/B testing & experimentation
140. Designing feature flag systems for safe rollouts
141. Designing modular & extensible microservices
142. Designing caching layers for read-heavy vs write-heavy workloads
143. Designing distributed task queues
144. Designing stateful vs stateless service interactions
145. Designing data pipelines with replay & idempotency
146. Designing disaster recovery strategies & RPO/RTO considerations
147. Designing telemetry & monitoring pipelines for large-scale services
148. Designing observability-first microservices
149. Designing secure authentication & authorization flows
150. Designing cost-optimized systems in cloud environments

---


