
# Time & Space Complexity in DSA (Using C)

Understanding time and space complexity helps you predict performance, compare algorithms, and write efficient C programs, especially for large inputs.

---

## 1. What is Time Complexity?

Time Complexity measures how the execution time of an algorithm grows as the input size `n` increases.

> It does not measure actual seconds
> It measures number of operations

### Why it matters in C

 C is fast, but bad algorithms are still slow
 Competitive programming & interviews focus heavily on this

---

## 2. What is Space Complexity?

Space Complexity measures how much extra memory an algorithm uses relative to input size.

Includes:

1. Input space
2. Extra variables
3. Recursion stack
4. Dynamic memory (`malloc`)

---

## 3. Asymptotic Notations (Core Concept)

As input size `n → ∞`, we analyze behavior using asymptotic notations:

| Notation          | Meaning                              |
| ----------------- | ------------------------------------ |
| Big-O (O)     | Upper bound (Worst case)             |
| Big-Theta (Θ) | Tight bound (Average / Exact growth) |
| Big-Omega (Ω) | Lower bound (Best case)              |

---

# 4. Big-O Notation (Worst Case)

### Definition

Big-O describes the maximum time an algorithm can take.

> “At worst, this algorithm will not be slower than O(f(n))”

---

### Example 1: Constant Time – O(1)

```c
int getFirst(int arr[], int n) {
    return arr[0];
}
```

 Always 1 operation
 Independent of `n`

✅ Time: O(1)
✅ Space: O(1)

---

### Example 2: Linear Time – O(n)

```c
int sum(int arr[], int n) {
    int s = 0;
    for(int i = 0; i < n; i++) {
        s += arr[i];
    }
    return s;
}
```

 Loop runs `n` times

✅ Time: O(n)
✅ Space: O(1)

---

### Example 3: Quadratic Time – O(n²)

```c
void printPairs(int arr[], int n) {
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            printf("%d %d\n", arr[i], arr[j]);
        }
    }
}
```

 Nested loops

✅ Time: O(n²)
❌ Very slow for large `n`

---

### Example 4: Logarithmic Time – O(log n)

```c
int binarySearch(int arr[], int n, int key) {
    int low = 0, high = n - 1;

    while(low <= high) {
        int mid = (low + high) / 2;
        if(arr[mid] == key)
            return mid;
        else if(arr[mid] < key)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1;
}
```

 Input halves every step

✅ Time: O(log n)
✅ Very efficient

---

# 5. Big-Theta Notation (Tight Bound)

### Definition

Big-Theta describes exact growth rate, when best and worst case are the same.

> “This algorithm always grows at this rate”

---

### Example: Θ(n)

```c
void printArray(int arr[], int n) {
    for(int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
}
```

 Always `n` operations

✅ Best = Worst = Average = Θ(n)

---

### Example: Θ(n log n)

 Merge Sort
 Heap Sort

They always run in `n log n` time regardless of input.

---

# 6. Big-Omega Notation (Best Case)

### Definition

Big-Omega describes the minimum time required.

> “At best, this algorithm will take at least Ω(f(n)) time”

---

### Example: Linear Search

```c
int linearSearch(int arr[], int n, int key) {
    for(int i = 0; i < n; i++) {
        if(arr[i] == key)
            return i;
    }
    return -1;
}
```

| Case                     | Time |
| ------------------------ | ---- |
| Best (first element)     | Ω(1) |
| Worst (last / not found) | O(n) |
| Average                  | Θ(n) |

---

# 7. Time Complexity Comparison Table

| Complexity | Name         | Practical Meaning   |
| ---------- | ------------ | ------------------- |
| O(1)       | Constant     | Best                |
| O(log n)   | Logarithmic  | Excellent           |
| O(n)       | Linear       | Acceptable          |
| O(n log n) | Linearithmic | Very good           |
| O(n²)      | Quadratic    | Slow                |
| O(2ⁿ)      | Exponential  | Useless for large n |

---

# 8. Space Complexity in C

### Example 1: Constant Space – O(1)

```c
int max(int a, int b) {
    return (a > b) ? a : b;
}
```

 Only variables
 No extra memory

---

### Example 2: Linear Space – O(n)

```c
int copyArray(int arr[], int n) {
    int copy = (int)malloc(n  sizeof(int));
    for(int i = 0; i < n; i++) {
        copy[i] = arr[i];
    }
    return copy;
}
```

 Extra array of size `n`

---

### Example 3: Recursion Stack – O(n)

```c
int factorial(int n) {
    if(n == 0)
        return 1;
    return n  factorial(n - 1);
}
```

 Recursive calls stored in stack

---

# 9. How to Calculate Time Complexity (Exam & Interview Method)

### Step-by-step:

1. Ignore constants
   `O(3n + 5) → O(n)`
2. Ignore lower terms
   `O(n² + n) → O(n²)`
3. Nested loops → multiply
4. Sequential loops → add
5. Recursion → write recurrence relation

---

# 10. Key Interview Takeaways (Very Important)

 Big-O = worst case (most asked)
 Always mention time + space
 Prefer:

   O(log n)
   O(n)
   O(n log n)
 Avoid O(n²) when `n > 10⁴`

---
