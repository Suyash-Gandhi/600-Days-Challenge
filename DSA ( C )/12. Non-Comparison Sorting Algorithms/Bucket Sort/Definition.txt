## 14. Non-Comparison Sorting Algorithms â€“ Bucket Sort

![Image](https://www.programiz.com/sites/tutorial2program/files/Bucket_2.png)

![Image](https://upload.wikimedia.org/wikipedia/commons/thumb/6/61/Bucket_sort_1.svg/1280px-Bucket_sort_1.svg.png)

---

### 1. What is Bucket Sort?

Bucket Sort is a non-comparison sorting algorithm that works by:

 Dividing elements into multiple buckets
 Sorting each bucket individually
 Concatenating all buckets to get the final sorted array

It is especially efficient when input data is uniformly distributed over a known range.

---

### 2. Why is Bucket Sort Non-Comparison?

 Elements are distributed into buckets based on range
 Sorting is achieved by grouping, not global comparisons
 Any comparison (if used) happens inside small buckets, not across the full dataset

---

### 3. Core Idea (How Bucket Sort Works)

Bucket Sort follows these steps:

1. Create empty buckets
2. Distribute elements into buckets based on value range
3. Sort each bucket (often using Insertion Sort)
4. Concatenate buckets in order

---

### 4. Step-by-Step Example

#### Input

```
[0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51]
```

Assume:

 Values are in range [0, 1)
 Number of buckets = number of elements

---

#### Step 1: Create Buckets

```
Bucket 0 â†’ []
Bucket 1 â†’ []
Bucket 2 â†’ []
Bucket 3 â†’ []
Bucket 4 â†’ []
Bucket 5 â†’ []
Bucket 6 â†’ []
```

---

#### Step 2: Distribute Elements

Bucket index = `n Ã— value`

```
0.42 â†’ Bucket 2
0.32 â†’ Bucket 2
0.33 â†’ Bucket 2
0.52 â†’ Bucket 3
0.37 â†’ Bucket 2
0.47 â†’ Bucket 3
0.51 â†’ Bucket 3
```

---

#### Step 3: Sort Individual Buckets

```
Bucket 2 â†’ [0.32, 0.33, 0.37, 0.42]
Bucket 3 â†’ [0.47, 0.51, 0.52]
```

(Other buckets remain empty)

---

#### Step 4: Concatenate Buckets

```
[0.32, 0.33, 0.37, 0.42, 0.47, 0.51, 0.52]
```

âœ… Array is sorted.

---

### 5. Time and Space Complexity

| Case    | Time Complexity |
| ------- | --------------- |
| Best    | O(n)        |
| Average | O(n + k)    |
| Worst   | O(nÂ²)       |

| Aspect | Complexity   |
| ------ | ------------ |
| Space  | O(n + k) |

Where:

 `n` = number of elements
 `k` = number of buckets

---

### 6. Stability

âœ… Bucket Sort can be stable
(depends on the sorting algorithm used inside each bucket)

 Insertion Sort â†’ Stable
 Quick Sort â†’ Not stable

---

### 7. When to Use Bucket Sort

Use Bucket Sort when:

 Data is uniformly distributed
 Input range is known
 Floating-point numbers are involved
 Average-case performance is critical

---

### 8. When NOT to Use Bucket Sort

âŒ Avoid when:

 Data is heavily skewed
 Range is unknown or very large
 Memory usage must be minimal

---

### 9. Bucket Sort vs Other Non-Comparison Sorts

| Feature      | Bucket Sort   | Counting Sort   | Radix Sort         |
| ------------ | ------------- | --------------- | ------------------ |
| Data Type    | Floats / Ints | Integers        | Integers / Strings |
| Distribution | Uniform       | Frequency-based | Digit-based        |
| Stable       | Depends       | Yes             | Yes                |
| Worst Case   | O(nÂ²)         | O(n + k)        | O(dÂ·n)             |
| Extra Space  | High          | High            | Moderate           |

---

### 10. Real-World Applications

 Sorting floating-point numbers
 Histogram-based data
 Preprocessing for clustering
 Uniformly distributed sensor data
 Graphics and image processing

---

### 11. Exam & Interview Key Points

 Bucket Sort assumes uniform distribution
 Performance degrades if buckets are unbalanced
 Choice of internal sort matters
 Not truly in-place

---

### 12. One-Line Summary

> Bucket Sort distributes elements into buckets, sorts each bucket individually, and merges them to efficiently sort uniformly distributed data.

---


## 1. First, forget the word â€œbucketâ€

Think of buckets as boxes or containers placed in order.

Imagine:

 You have numbers spread across a known range
 Instead of comparing every number with every other number,
 You group nearby numbers together

That grouping is the entire idea of Bucket Sort.

---

## 2. Why buckets even work (core intuition)

### Key assumption

> Numbers that are close in value should end up close in position

Example:

 0.31 and 0.32 â†’ should be near each other
 0.31 and 0.95 â†’ definitely far apart

So instead of sorting everything at once:

1. Divide the number line into ranges
2. Put numbers into the range they belong to
3. Sort only inside each small range

This reduces work if numbers are evenly spread.

---

## 3. The input we are sorting

Weâ€™ll use this exact array throughout:

```
[0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51]
```

### Important observation

 All values are between 0 and 1
 They are decimal numbers
 Total elements = 7

---

## 4. How many buckets do we create?

### Common rule (simple and safe):

> Number of buckets = number of elements

So:

```
n = 7
Buckets = 7
```

We label them:

```
Bucket 0
Bucket 1
Bucket 2
Bucket 3
Bucket 4
Bucket 5
Bucket 6
```

Each bucket represents a range of values.

---

## 5. What range does each bucket represent?

Since values are between 0 and 1:

Each bucket size =

```
range / number of buckets = 1 / 7 â‰ˆ 0.14
```

So buckets cover:

| Bucket | Value Range |
| ------ | ----------- |
| 0      | 0.00 â€“ 0.14 |
| 1      | 0.14 â€“ 0.28 |
| 2      | 0.28 â€“ 0.42 |
| 3      | 0.42 â€“ 0.56 |
| 4      | 0.56 â€“ 0.70 |
| 5      | 0.70 â€“ 0.84 |
| 6      | 0.84 â€“ 1.00 |

---

## 6. How do we decide which bucket a value goes into?

We use this simple formula:

```
bucket_index = n Ã— value
```

(Then take integer part)

Why this works:

 Value is between 0 and 1
 Multiplying by `n` scales it into bucket numbers

---

## 7. Putting EACH value into a bucket (slowly)

Letâ€™s do this one number at a time.

---

### ğŸ”¹ Value: 0.42

```
7 Ã— 0.42 = 2.94 â†’ Bucket 2
```

Bucket 2:

```
[0.42]
```

---

### ğŸ”¹ Value: 0.32

```
7 Ã— 0.32 = 2.24 â†’ Bucket 2
```

Bucket 2:

```
[0.42, 0.32]
```

---

### ğŸ”¹ Value: 0.33

```
7 Ã— 0.33 = 2.31 â†’ Bucket 2
```

Bucket 2:

```
[0.42, 0.32, 0.33]
```

---

### ğŸ”¹ Value: 0.52

```
7 Ã— 0.52 = 3.64 â†’ Bucket 3
```

Bucket 3:

```
[0.52]
```

---

### ğŸ”¹ Value: 0.37

```
7 Ã— 0.37 = 2.59 â†’ Bucket 2
```

Bucket 2:

```
[0.42, 0.32, 0.33, 0.37]
```

---

### ğŸ”¹ Value: 0.47

```
7 Ã— 0.47 = 3.29 â†’ Bucket 3
```

Bucket 3:

```
[0.52, 0.47]
```

---

### ğŸ”¹ Value: 0.51

```
7 Ã— 0.51 = 3.57 â†’ Bucket 3
```

Bucket 3:

```
[0.52, 0.47, 0.51]
```

---

## 8. Situation after distribution (VERY IMPORTANT)

Buckets now look like this:

```
Bucket 0 â†’ []
Bucket 1 â†’ []
Bucket 2 â†’ [0.42, 0.32, 0.33, 0.37]
Bucket 3 â†’ [0.52, 0.47, 0.51]
Bucket 4 â†’ []
Bucket 5 â†’ []
Bucket 6 â†’ []
```

### ğŸ”‘ Key realization

 All numbers in Bucket 2 are smaller than all numbers in Bucket 3
 So no comparison is needed across buckets

Thatâ€™s the magic.

---

## 9. Why do we sort INSIDE each bucket?

Because:

 Values in the same bucket are close together
 Buckets are small
 Simple sorting (Insertion Sort) is very fast here

---

### Sorting Bucket 2

```
[0.42, 0.32, 0.33, 0.37]
â†’ [0.32, 0.33, 0.37, 0.42]
```

### Sorting Bucket 3

```
[0.52, 0.47, 0.51]
â†’ [0.47, 0.51, 0.52]
```

Other buckets are empty.

---

## 10. Final step: concatenate buckets

Now we join buckets in order:

```
Bucket 0
Bucket 1
Bucket 2
Bucket 3
Bucket 4
Bucket 5
Bucket 6
```

Result:

```
[0.32, 0.33, 0.37, 0.42, 0.47, 0.51, 0.52]
```

ğŸ‰ Sorted array achieved

---

## 11. Why this is fast (when it works)

Bucket Sort is fast ONLY IF:

 Data is uniformly distributed
 Buckets stay small

Then:

 Distribution â†’ O(n)
 Sorting tiny buckets â†’ almost O(1)
 Total â‰ˆ O(n)

---

## 12. Why it can become slow

Worst case:

 All values fall into one bucket
 That bucket needs full sorting
 Time â†’ O(nÂ²)

This is why uniform distribution is critical.

---

## 13. One mental model to remember forever

> Bucket Sort = divide number line â†’ group nearby values â†’ sort locally â†’ merge

No magic. No shortcuts. Just controlled grouping.

---



# â“ Core Confusion You Have

> â€œHow do I know that 0.42 should go to Bucket 2?
> I only know the range is 0â€“1.
> Who decided Bucket 2?â€

âœ… Correct doubt. You are thinking properly.

---

## 1. The MOST IMPORTANT RULE (that answers everything)

Bucket Sort does NOT automatically know bucket ranges.

ğŸ‘‰ WE define the rule.

The algorithm designer must decide:

1. How many buckets
2. How to map a value to a bucket

There is NO universal bucket rule.

---

## 2. What we KNOW before creating buckets

From the problem:

 Values lie in range [0, 1)
 Number of elements `n = 7`

Thatâ€™s all the information we start with.

---

## 3. Why do we choose `n` buckets?

This is a design choice, not a law.

Why itâ€™s common:

 Average case â†’ ~1 element per bucket
 Keeps buckets small
 Makes sorting inside buckets cheap

But we could choose:

 5 buckets
 10 buckets
 100 buckets

Algorithm still works (performance changes).

---

## 4. Once we choose number of buckets, ranges AUTOMATICALLY appear

We chose:

```
Buckets = 7
Total range = 1 (from 0 to 1)
```

So each bucket covers:

```
bucket_width = total_range / number_of_buckets
             = 1 / 7 â‰ˆ 0.14
```

âš ï¸ This is the missing step most explanations skip

---

## 5. Now buckets DO have ranges (derived, not given)

| Bucket | Range        |
| ------ | ------------ |
| 0      | [0.00, 0.14) |
| 1      | [0.14, 0.28) |
| 2      | [0.28, 0.42) |
| 3      | [0.42, 0.56) |
| 4      | [0.56, 0.70) |
| 5      | [0.70, 0.84) |
| 6      | [0.84, 1.00) |

âœ… These ranges were calculated, not assumed.

---

## 6. Now answer your exact example: 0.42

Letâ€™s place `0.42`.

### Method 1 (Range logic â€” intuitive)

Check ranges:

 Bucket 2 â†’ ends at 0.42
 Bucket 3 â†’ starts at 0.42

ğŸ‘‰ Convention:

 Left inclusive
 Right exclusive

So:

```
0.42 âˆˆ [0.42, 0.56)
â†’ Bucket 3
```

ğŸ’¡ So logically, 0.42 belongs to Bucket 3

---

## 7. Then why did formula put it in Bucket 2?

Now comes the IMPORTANT PART.

### Formula used:

```
bucket_index = floor(n Ã— value)
```

For 0.42:

```
7 Ã— 0.42 = 2.94
floor(2.94) = 2
```

This slightly shifts boundaries due to:

 Floating-point rounding
 Simplification for implementation

---

## 8. Is this a mistake? âŒ NO

Because:

 0.42 is close to the boundary
 Whether it goes to Bucket 2 or 3:

   It will still be sorted inside the bucket
   Final result remains correct

ğŸ‘‰ Bucket Sort is approximate during distribution, exact during final sorting.

---

## 9. The REAL invariant (this is what matters)

Bucket Sort only needs ONE condition:

> If x < y, then bucket(x) â‰¤ bucket(y)

Thatâ€™s it.

As long as:

 Smaller numbers donâ€™t go to higher buckets
 Larger numbers donâ€™t go to lower buckets

The algorithm is correct.

---

## 10. Why the formula works mathematically

Let value `v âˆˆ [0,1)`.

Multiply:

```
0 â‰¤ v < 1
0 â‰¤ nÃ—v < n
```

Taking floor:

```
bucket_index âˆˆ {0, 1, 2, ..., n-1}
```

So:

 All values map cleanly into valid buckets
 Order is preserved approximately

---

## 11. Think of buckets as â€œrough zonesâ€, NOT exact boxes

Bucket Sort does NOT say:

> â€œThis is the final positionâ€

It says:

> â€œThese numbers belong roughly hereâ€

Final correctness comes from sorting inside buckets.

---

## 12. If this were integers, it would feel obvious

Example:

```
Range: 0â€“99
Buckets: 10
```

Bucket size = 10

```
34 â†’ bucket 3
87 â†’ bucket 8
```

No confusion.

For decimals, it feels confusing because ranges are implicit.

---

## 13. Final mental model (remember this forever)

> Buckets are created by dividing the range evenly after choosing how many buckets.
> The formula is just a shortcut to compute the same thing.

---

## 14. Short answer to your question

> â“ â€œHow do I know 0.42 goes to bucket 2?â€

You donâ€™t â€œknowâ€ it beforehand.
You DEFINE the mapping rule.
The formula creates bucket ranges automatically.

---

