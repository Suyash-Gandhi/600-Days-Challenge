
## 🧩 1. Variables in Rust

In Rust, variables are declared using the keyword `let`.
By default, variables in Rust are immutable — meaning their values cannot be changed once assigned.

### Example:

```rust
fn main() {
    let x = 10;  
    println!("x = {}", x);
    
    // x = 20; ❌ This would cause a compile-time error
}
```

🧠 Reason:
Rust enforces immutability by default to ensure thread safety, predictability, and avoid accidental data races.

---

## 🔁 2. Making Variables Mutable

If you want a variable’s value to be changeable, you must explicitly declare it as mutable using the `mut` keyword.

### Example:

```rust
fn main() {
    let mut count = 5;
    println!("count = {}", count);
    
    count = 10;  // ✅ Allowed
    println!("count = {}", count);
}
```

✅ Output:

```
count = 5
count = 10
```

💡 Note:

 Mutability applies to the binding, not the data.
  If a variable holds a reference to a value, marking it mutable allows changing what it points to, not necessarily the value itself.

---

## 🧱 3. Constants in Rust

Constants are always immutable — you cannot make them mutable, and they are defined using the `const` keyword.

### Example:

```rust
const MAX_SCORE: u32 = 100;

fn main() {
    println!("The maximum score is {}", MAX_SCORE);
}
```

🧩 Key Points about Constants:

 Must have a type annotation (`u32`, `i64`, etc.).
 Cannot be declared as `mut`.
 Must be assigned with a constant expression, not the result of a function or runtime value.
 Are valid for the entire program lifetime.

### ❌ Invalid Constant Example:

```rust
const USER_AGE: i32 = get_age();  // Error ❌
```

> You can’t call a function to assign a constant — it must be a compile-time known value.

---

## 🔄 4. Shadowing

Rust allows shadowing — you can declare a new variable with the same name as a previous one.
This new variable “shadows” the old one.

### Example:

```rust
fn main() {
    let x = 5;
    let x = x + 1;   // shadowing previous x
    let x = x * 2;   // shadowing again
    
    println!("x = {}", x);
}
```

✅ Output:

```
x = 12
```

💬 Difference Between Shadowing and `mut`:

| Feature                     | Shadowing     | `mut`          |
| --------------------------- | ------------- | -------------- |
| Creates new variable        | ✅ Yes         | ❌ No           |
| Type can change             | ✅ Yes         | ❌ No           |
| Memory address              | New each time | Same           |
| Safe & Immutable by default | ✅ Yes         | ❌ No (mutable) |

### Example showing type change with shadowing:

```rust
fn main() {
    let spaces = "   ";
    let spaces = spaces.len();  // type changes from &str → usize
    println!("spaces = {}", spaces);
}
```

---

## ⚙️ 5. Practical Example — Combining All Concepts

```rust
const MAX_POINTS: u32 = 100_000;

fn main() {
    let mut score = 50;
    println!("Initial score: {}", score);

    score = 75;
    println!("Updated score: {}", score);

    let score = score + 25; // shadowing
    println!("Final score: {}", score);

    println!("Max possible points: {}", MAX_POINTS);
}
```

✅ Output:

```
Initial score: 50
Updated score: 75
Final score: 100
Max possible points: 100000
```

---

## 🧠 Summary Table

| Concept          | Keyword   | Mutable        | Requires Type | Compile-Time Value | Can Rebind (Shadow) |
| ---------------- | --------- | -------------- | ------------- | ------------------ | ------------------- |
| Variable         | `let`     | ❌ (by default) | Optional      | No                 | Yes                 |
| Mutable Variable | `let mut` | ✅              | Optional      | No                 | Yes                 |
| Constant         | `const`   | ❌              | ✅ Required    | ✅ Yes              | No                  |

---

## 🚀 Best Practices

1. Prefer immutability — use `let` unless you truly need `mut`.

   > Safer, easier to reason about, and more Rust-idiomatic.

2. Use constants for global fixed values — like config limits, mathematical constants, etc.

3. Shadow instead of mut — when you want to transform a variable’s value or type step by step.

