
## ðŸ§© 1. Variables in Rust

In Rust, variables are declared using the keyword `let`.
By default, variables in Rust are immutable â€” meaning their values cannot be changed once assigned.

### Example:

```rust
fn main() {
    let x = 10;  
    println!("x = {}", x);
    
    // x = 20; âŒ This would cause a compile-time error
}
```

ðŸ§  Reason:
Rust enforces immutability by default to ensure thread safety, predictability, and avoid accidental data races.

---

## ðŸ” 2. Making Variables Mutable

If you want a variableâ€™s value to be changeable, you must explicitly declare it as mutable using the `mut` keyword.

### Example:

```rust
fn main() {
    let mut count = 5;
    println!("count = {}", count);
    
    count = 10;  // âœ… Allowed
    println!("count = {}", count);
}
```

âœ… Output:

```
count = 5
count = 10
```

ðŸ’¡ Note:

 Mutability applies to the binding, not the data.
  If a variable holds a reference to a value, marking it mutable allows changing what it points to, not necessarily the value itself.

---

## ðŸ§± 3. Constants in Rust

Constants are always immutable â€” you cannot make them mutable, and they are defined using the `const` keyword.

### Example:

```rust
const MAX_SCORE: u32 = 100;

fn main() {
    println!("The maximum score is {}", MAX_SCORE);
}
```

ðŸ§© Key Points about Constants:

 Must have a type annotation (`u32`, `i64`, etc.).
 Cannot be declared as `mut`.
 Must be assigned with a constant expression, not the result of a function or runtime value.
 Are valid for the entire program lifetime.

### âŒ Invalid Constant Example:

```rust
const USER_AGE: i32 = get_age();  // Error âŒ
```

> You canâ€™t call a function to assign a constant â€” it must be a compile-time known value.

---

## ðŸ”„ 4. Shadowing

Rust allows shadowing â€” you can declare a new variable with the same name as a previous one.
This new variable â€œshadowsâ€ the old one.

### Example:

```rust
fn main() {
    let x = 5;
    let x = x + 1;   // shadowing previous x
    let x = x * 2;   // shadowing again
    
    println!("x = {}", x);
}
```

âœ… Output:

```
x = 12
```

ðŸ’¬ Difference Between Shadowing and `mut`:

| Feature                     | Shadowing     | `mut`          |
| --------------------------- | ------------- | -------------- |
| Creates new variable        | âœ… Yes         | âŒ No           |
| Type can change             | âœ… Yes         | âŒ No           |
| Memory address              | New each time | Same           |
| Safe & Immutable by default | âœ… Yes         | âŒ No (mutable) |

### Example showing type change with shadowing:

```rust
fn main() {
    let spaces = "   ";
    let spaces = spaces.len();  // type changes from &str â†’ usize
    println!("spaces = {}", spaces);
}
```

---

## âš™ï¸ 5. Practical Example â€” Combining All Concepts

```rust
const MAX_POINTS: u32 = 100_000;

fn main() {
    let mut score = 50;
    println!("Initial score: {}", score);

    score = 75;
    println!("Updated score: {}", score);

    let score = score + 25; // shadowing
    println!("Final score: {}", score);

    println!("Max possible points: {}", MAX_POINTS);
}
```

âœ… Output:

```
Initial score: 50
Updated score: 75
Final score: 100
Max possible points: 100000
```

---

## ðŸ§  Summary Table

| Concept          | Keyword   | Mutable        | Requires Type | Compile-Time Value | Can Rebind (Shadow) |
| ---------------- | --------- | -------------- | ------------- | ------------------ | ------------------- |
| Variable         | `let`     | âŒ (by default) | Optional      | No                 | Yes                 |
| Mutable Variable | `let mut` | âœ…              | Optional      | No                 | Yes                 |
| Constant         | `const`   | âŒ              | âœ… Required    | âœ… Yes              | No                  |

---

## ðŸš€ Best Practices

1. Prefer immutability â€” use `let` unless you truly need `mut`.

   > Safer, easier to reason about, and more Rust-idiomatic.

2. Use constants for global fixed values â€” like config limits, mathematical constants, etc.

3. Shadow instead of mut â€” when you want to transform a variableâ€™s value or type step by step.

