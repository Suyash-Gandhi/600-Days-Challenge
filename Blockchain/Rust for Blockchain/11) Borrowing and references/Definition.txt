

## 🔹 1. What Is Borrowing in Rust?

In Rust, borrowing means giving temporary access to data owned by another variable without taking ownership of it.
This is done through references using the `&` symbol.

Think of it as lending your book to a friend — they can read it, but they don’t own it; you still do.

---

## 🔹 2. The Need for Borrowing

If every time you passed a variable to a function, ownership was transferred, it would be very restrictive:

```rust
fn main() {
    let s = String::from("hello");
    takes_ownership(s); // s is moved here
    println!("{}", s); // ❌ Error: s no longer valid
}

fn takes_ownership(s: String) {
    println!("{}", s);
}
```

Here, `s` is moved into the function. After the call, `s` is invalid.
This is inconvenient if we just want to read the value.

Borrowing solves this by passing a reference instead.

---

## 🔹 3. Immutable References (`&T`)

You can pass a reference using `&` to let a function read data without taking ownership.

```rust
fn main() {
    let s = String::from("hello");
    let len = calculate_length(&s);
    println!("The length of '{}' is {}.", s, len);
}

fn calculate_length(s: &String) -> usize {
    s.len() // We can read, but not modify
}
```

### ✅ Key points:

 `&s` → Borrow an immutable reference.
 `s` → Still owns the data.
 The function cannot modify the borrowed data.

---

## 🔹 4. Mutable References (`&mut T`)

If you need to modify the data you borrowed, use a mutable reference.

```rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
    println!("{}", s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world!");
}
```

### ✅ Rules for mutable references:

1. You can have only one mutable reference to a value at a time.
   (Prevents data races)
2. You cannot have both a mutable and immutable reference at the same time.

Example of violation:

```rust
let mut s = String::from("hello");
let r1 = &s;
let r2 = &mut s; // ❌ Error: cannot borrow as mutable because it’s already borrowed as immutable
```

---

## 🔹 5. Dangling References (Invalid References)

Rust prevents references that point to invalid memory (known as dangling pointers).

Example (❌ won’t compile):

```rust
fn dangle() -> &String { // returns reference
    let s = String::from("hello");
    &s // ❌ s is dropped when function ends
}
```

✅ Correct way:

```rust
fn no_dangle() -> String {
    let s = String::from("hello");
    s // ownership is moved, no dangling reference
}
```

---

## 🔹 6. Borrow Checker

Rust’s borrow checker enforces all these rules at compile time:

 No simultaneous mutable and immutable references.
 No dangling references.
 Lifetimes of references are tracked to ensure validity.

---

## 🔹 7. Multiple Immutable References

You can have multiple immutable references because they’re read-only and do not mutate data.

```rust
let s = String::from("hello");
let r1 = &s;
let r2 = &s; // ✅ multiple immutable borrows allowed
println!("{} and {}", r1, r2);
```

But you cannot mix mutable and immutable ones:

```rust
let mut s = String::from("hello");
let r1 = &s;
let r2 = &mut s; // ❌ not allowed
```

---

## 🔹 8. Scope of References

References are valid only within their scope. Once a reference goes out of scope, you can safely create another one.

```rust
let mut s = String::from("hello");

{
    let r1 = &mut s;
    r1.push_str(" world");
} // r1 goes out of scope here

let r2 = &mut s; // ✅ allowed again
println!("{}", r2);
```

---

## 🔹 9. Summary Table

| Type                | Syntax   | Mutability   | Ownership | Simultaneous Access |
| ------------------- | -------- | ------------ | --------- | ------------------- |
| Immutable Reference | `&T`     | Read-only    | Not taken | Many allowed        |
| Mutable Reference   | `&mut T` | Read + Write | Not taken | Only one allowed    |
| Ownership Transfer  | `T`      | Full control | Moved     | Only one owner      |

---

## 🔹 10. Real-World Analogy

Imagine you own a book:

 You can lend it to multiple friends to read (immutable borrow).
 You can lend it to one friend to edit (mutable borrow).
 You can’t lend it to others until it’s returned.
 When you give it away (move ownership), you no longer have it.

