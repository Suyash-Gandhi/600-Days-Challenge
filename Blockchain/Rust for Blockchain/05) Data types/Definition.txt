
## ğŸ§© 1. Categories of Data Types

Rustâ€™s data types fall into two main categories:

### A. Scalar Types

Represent a single value (number, character, boolean).

### B. Compound Types

Group multiple values into one type (like tuples and arrays).

---

## ğŸ§® 2. Scalar Types

### (i) Integers

 Whole numbers â€” positive or negative â€” without a decimal point.
 Can be signed (i) or unsigned (u).

   Signed â†’ can store negative and positive values
   Unsigned â†’ only positive values

| Length       | Signed  | Unsigned | Range (Signed)                |
| ------------ | ------- | -------- | ----------------------------- |
| 8-bit        | `i8`    | `u8`     | -128 to 127                   |
| 16-bit       | `i16`   | `u16`    | -32,768 to 32,767             |
| 32-bit       | `i32`   | `u32`    | -2Â³Â¹ to 2Â³Â¹-1                 |
| 64-bit       | `i64`   | `u64`    | -2â¶Â³ to 2â¶Â³-1                 |
| 128-bit      | `i128`  | `u128`   | -2Â¹Â²â· to 2Â¹Â²â·-1               |
| Architecture | `isize` | `usize`  | Depends on system (32/64-bit) |

Example:

```rust
let a: i32 = -10;
let b: u8 = 255;
```

---

### (ii) Floating-Point Numbers

For decimal or fractional numbers.

| Type  | Precision                    | Example     |
| ----- | ---------------------------- | ----------- |
| `f32` | Single (32-bit)              | 3.14        |
| `f64` | Double (64-bit, default) | 2.718281828 |

Example:

```rust
let x = 2.5; // f64 by default
let y: f32 = 3.14;
```

---

### (iii) Boolean

Has only two values: `true` or `false`.

Example:

```rust
let is_active: bool = true;
```

Used frequently in conditionals:

```rust
if is_active {
    println!("Active");
}
```

---

### (iv) Character (`char`)

Represents a single Unicode character (not just ASCII).
Each `char` is 4 bytes.

Example:

```rust
let letter = 'A';
let heart = 'â¤';
let smiley = 'ğŸ˜Š';
```

In Rust, a `char` represents exactly one Unicode scalar value â€” that means a single character, not a string or group of characters.

So, this is âœ… valid:

```rust
let letter: char = 'A';
let heart: char = 'â¤';
let emoji: char = 'ğŸ˜Š';
```

But this is âŒ invalid:

```rust
let word: char = 'AB'; // âŒ ERROR: character literal may only contain one character
```

Youâ€™ll get a compiler error because `'AB'` is two characters, and `char` expects only one.

---

## âœ… To Store Multiple Characters â€” Use `&str`

If you want to store multiple characters (like a word, sentence, or name), use a string slice (`&str`) or a `String` type.

### Example 1 â€” String Slice (`&str`):

```rust
let greeting: &str = "Hello";
```

 Stored in read-only memory (string literal).
 Fast and lightweight.
 Cannot be modified.

### Example 2 â€” String (`String`):

```rust
let mut name: String = String::from("Suyash");
name.push('!'); // Add a character at the end
```

 Stored on the heap.
 Growable and modifiable.
 Commonly used when you need to change or build strings dynamically.

---

## ğŸ§  Summary

| Type     | Description                      | Example              | Can Hold Multiple Characters? |
| -------- | -------------------------------- | -------------------- | ----------------------------- |
| `char`   | Single Unicode scalar value      | `'A'`, `'ğŸ˜Š'`        | âŒ No                          |
| `&str`   | String slice (fixed)             | `"Hello"`            | âœ… Yes                         |
| `String` | Growable string (heap-allocated) | `String::from("Hi")` | âœ… Yes                         |

---

ğŸ’¡ Tip:

 Think of `'A'` as a character (`char`)
 And `"A"` as a string (`&str`)

They look similar but are completely different types in Rust.


---

## ğŸ§± 3. Compound Types

### (i) Tuple

A fixed-size collection of values of different types.

Example:

```rust
let person: (i32, f64, char) = (25, 5.9, 'M');

// Access elements:
println!("{}", person.0); // 25
println!("{}", person.1); // 5.9
println!("{}", person.2); // M

// Destructuring
let (age, height, gender) = person;
```

---

### (ii) Array

A fixed-size collection of values of the same type stored sequentially in memory.

Example:

```rust
let scores = [90, 85, 88, 92];
let days: [&str; 3] = ["Mon", "Tue", "Wed"];
println!("{}", days[0]); // Mon
```

 Arrays have fixed length.
 For dynamic or growable lists, Rust provides vectors (`Vec<T>`).

---

## âš™ï¸ 4. Type Inference

Rust can often infer the type automatically:

```rust
let x = 42;      // inferred as i32
let y = 3.14;    // inferred as f64
```

You can specify it manually when needed:

```rust
let z: u8 = 255;
```

---

## ğŸ“ 5. Type Conversion

Rust doesnâ€™t perform implicit type conversion.
You must explicitly cast using the `as` keyword:

```rust
let a: i32 = 10;
let b: f64 = a as f64 + 0.5;
```

---

## ğŸ”’ 6. Constants and Type Annotation

Constants always need an explicit type:

```rust
const MAX_POINTS: u32 = 100_000;
```

---

## ğŸ§  Summary

| Category | Type      | Example                  |
| -------- | --------- | ------------------------ |
| Scalar   | Integer   | `let a: i32 = 10;`       |
| Scalar   | Float     | `let b: f64 = 3.14;`     |
| Scalar   | Boolean   | `let c: bool = true;`    |
| Scalar   | Character | `let d: char = 'A';`     |
| Compound | Tuple     | `let t = (1, 2.0, 'A');` |
| Compound | Array     | `let arr = [1, 2, 3];`   |

---

Excellent â€” youâ€™re entering one of the core concepts in Rustâ€™s memory model now.
Letâ€™s break slices down carefully, with examples and comparisons so you understand both what they are and why they matter ğŸ‘‡

---

## ğŸ§© What Is a Slice in Rust?

A slice in Rust is a reference to a contiguous sequence of elements in a collection (like an array, vector, or string).
It doesnâ€™t own the data â€” it just borrows a view into it.

Think of it like saying:

> â€œHey, I want to look at part of this collection â€” not copy or own it.â€

---

## ğŸ§  Why Slices Exist

Rust emphasizes ownership and borrowing for memory safety.
If you want to access a portion of data without taking ownership of the entire thing, slices let you safely do that.

---

## ğŸ“¦ 1. Array Slices

### Example:

```rust
let numbers = [10, 20, 30, 40, 50];

// Slice from index 1 to 3 (excludes index 3)
let slice = &numbers[1..3];

println!("{:?}", slice); // [20, 30]
```

âœ… Key points:

 `&numbers[1..3]` â†’ takes elements from index 1 up to (but not including) index 3.
 The slice here is a reference, not a new array.
 The type of `slice` is `&[i32]`.

---

### You can also omit range boundaries:

```rust
let slice_all = &numbers[..];     // full slice
let first_two = &numbers[..2];    // from start to index 2 (excluded)
let last_two = &numbers[3..];     // from index 3 to end
```

---

## ğŸ“œ 2. String Slices

A string slice (`&str`) is actually a slice of a stringâ€™s bytes.

### Example:

```rust
let message = String::from("Hello Rust");

// Slice of string
let hello = &message[0..5];
println!("{}", hello); // Hello
```

âœ… `&message[0..5]` gives you `"Hello"`, not a new string â€” just a borrowed part.

> âš ï¸ Important:
> String slices must be valid UTF-8 boundaries â€” slicing in the middle of a multibyte character (like emojis) causes a runtime panic.

---

### String Literals Are Slices Too!

```rust
let greeting: &str = "Hi there";
```

Here, `"Hi there"` is already a string slice â€” itâ€™s stored in the programâ€™s binary and points to read-only memory.

---

## âš™ï¸ 3. Mutable Slices

You can also create mutable slices using `&mut`.

```rust
let mut numbers = [1, 2, 3, 4];
let slice = &mut numbers[1..3];
slice[0] = 99;
println!("{:?}", numbers); // [1, 99, 3, 4]
```

âœ… Here, `slice` borrows part of the array mutably, allowing you to modify the original array data safely.

---

## ğŸ§­ 4. Slice Type Signatures

Letâ€™s look at how Rust represents slice types:

| Collection          | Slice Type   |
| ------------------- | ------------ |
| Array of `i32`      | `&[i32]`     |
| Mutable array slice | `&mut [i32]` |
| String slice        | `&str`       |

---

## ğŸ§® 5. How Slices Work Internally

Under the hood, a slice is made up of:

1. A pointer to the starting element.
2. A length.

So, `&numbers[1..3]` holds:

 pointer â†’ address of `numbers[1]`
 length â†’ `2`

This makes slices lightweight and efficient â€” they donâ€™t copy data, just borrow references.

---

## ğŸ§± 6. Example: Passing Slices to Functions

```rust
fn sum(numbers: &[i32]) -> i32 {
    let mut total = 0;
    for &num in numbers {
        total += num;
    }
    total
}

fn main() {
    let arr = [1, 2, 3, 4, 5];
    println!("Sum: {}", sum(&arr[1..4])); // Sum: 9
}
```

âœ… The function accepts any slice of integers, not just arrays â€” very flexible and memory-safe.

---

## ğŸ§  Summary

| Concept       | Description       | Example          | Type       |
| ------------- | ----------------- | ---------------- | ---------- |
| Array slice   | Part of an array  | `&arr[1..3]`     | `&[T]`     |
| String slice  | Part of a string  | `&text[0..5]`    | `&str`     |
| Mutable slice | Writable portion  | `&mut arr[1..3]` | `&mut [T]` |
| Full slice    | Entire collection | `&arr[..]`       | `&[T]`     |

---

### ğŸ” Analogy

Imagine you have a book (`String` or `Array`).

 A slice is like looking at a few pages without tearing them out.
 Youâ€™re borrowing those pages temporarily, not owning them.

