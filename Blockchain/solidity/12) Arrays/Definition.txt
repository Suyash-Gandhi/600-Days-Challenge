
## 1. What is an Array in Solidity?

An array is a collection of elements of the same type. In Solidity, arrays can be fixed-size or dynamic. Arrays are commonly used to store lists like numbers, addresses, strings, or structs.

---

## 2. Types of Arrays

### A. Fixed-Size Arrays

 The length is defined at compile time and cannot be changed later.
 Syntax:


type[array_size] arrayName;


Example:


pragma solidity ^0.8.0;

contract FixedArrayExample {
    uint[3] public numbers = [1, 2, 3];

    function getFirstNumber() public view returns (uint) {
        return numbers[0]; // returns 1
    }

    function setNumber(uint index, uint value) public {
        numbers[index] = value; // modify value at a specific index
    }
}


✅ Key Points:

 Access elements using index: arrayName[index].
 Cannot push new elements because the size is fixed.
 If you try to access an index out of range, it will revert.

---

### B. Dynamic Arrays

 Size is not fixed; elements can be added or removed during runtime.
 Syntax:


type[] arrayName;


Example:


pragma solidity ^0.8.0;

contract DynamicArrayExample {
    uint[] public numbers;

    function addNumber(uint _number) public {
        numbers.push(_number); // add element to the end
    }

    function removeLastNumber() public {
        numbers.pop(); // remove last element
    }

    function getNumber(uint index) public view returns (uint) {
        return numbers[index];
    }

    function getLength() public view returns (uint) {
        return numbers.length;
    }
}


✅ Key Points:

 Use .push() to add elements.
 Use .pop() to remove the last element.
 Access elements via index, just like fixed-size arrays.
 Length can be obtained using .length.

---

### C. Array of Structs or Complex Types

Arrays can also hold structs or other arrays.

Example:


pragma solidity ^0.8.0;

contract StructArrayExample {
    struct Person {
        string name;
        uint age;
    }

    Person[] public people;

    function addPerson(string memory _name, uint _age) public {
        people.push(Person(_name, _age));
    }

    function getPerson(uint index) public view returns (string memory, uint) {
        Person memory p = people[index];
        return (p.name, p.age);
    }
}


---


## 4. Important Notes

1. Memory Arrays: Can be declared temporarily inside functions.


uint ; // fixed size in memory


 These exist only during function execution.
 Cannot use .push() on memory arrays.


3. State vs Local Arrays:

Absolutely! Let’s dive deeply and clearly into State vs Local Arrays in Solidity. This is a crucial concept because it affects storage, gas cost, and lifetime of data.

---

## 1. State Arrays

### Definition

 State arrays are stored on the blockchain, in contract storage.
 They persist between function calls and are visible across transactions.
 Modifying them costs gas because blockchain storage is expensive.

### Syntax / Example


pragma solidity ^0.8.0;

contract StateArrayExample {
    uint[] public numbers; // State array

    function addNumber(uint _number) public {
        numbers.push(_number); // modifies state, costs gas
    }

    function getNumber(uint index) public view returns (uint) {
        return numbers[index]; // read from blockchain storage
    }

    function getLength() public view returns (uint) {
        return numbers.length;
    }
}


✅ Key Points:

 Stored permanently on blockchain.
 Any modification costs gas.
 Can be dynamic or fixed-size.
 Accessible by other functions in the contract and from outside (if public).

---

## 2. Local Arrays

### Definition

 Local arrays exist only inside a function.
 Stored in memory (temporary) or stack.
 They do not persist after the function execution ends.
 Cheaper than state arrays since no storage is used.

### Syntax / Example


pragma solidity ^0.8.0;

contract LocalArrayExample {
    function temporaryArray() public pure returns (uint[] memory) {
        uint ; // local array in memory
        temp[0] = 10;
        temp[1] = 20;
        temp[2] = 30;
        return temp; // only exists during function execution
    }
}


3. Memory Arrays

Memory arrays are arrays explicitly stored in memory.

They exist only during function execution.

Used for temporary computations, cannot persist after the function ends.

Can be local arrays, or function parameters/return values.

Example:

function memoryArrayExample() public pure returns (uint[] memory) {
    uint ; // memory array of size 3
    return tempArray;
}


✅ Key Points:

 Stored in memory, not on blockchain.
 Can only exist inside functions.
 .push() is not allowed on memory arrays (because memory size is fixed when created).
 No gas cost for writing to memory arrays (only cost for computation, not storage).

---

4. Nested Arrays in Solidity
Definition

Nested arrays are arrays of arrays.

Can be fixed or dynamic, and can exist in storage or memory.

Useful for 2D data, like a matrix, leaderboard, or grid.

Fixed-Size Nested Array
pragma solidity ^0.8.0;

contract FixedNestedArray {
    uint[2][3] public matrix; // 3 rows, 2 columns

    function setMatrix() public {
        matrix[0] = [1, 2];
        matrix[1] = [3, 4];
        matrix[2] = [5, 6];
    }

    function getValue(uint row, uint col) public view returns (uint) {
        return matrix[row][col];
    }
}

Dynamic Nested Array
pragma solidity ^0.8.0;

contract DynamicNestedArray {
    uint[][] public matrix; // dynamic array of dynamic arrays

    function addRow(uint[] memory row) public {
        matrix.push(row); // add a new row
    }

    function getValue(uint row, uint col) public view returns (uint) {
        return matrix[row][col];
    }
}


✅ Key Points

Nested arrays can be fixed-size inside dynamic arrays, or fully dynamic.

When using memory nested arrays, you must specify sizes for inner arrays if you want to modify them.

Useful for complex data structures, like storing multiple user addresses or mapping multiple properties.


