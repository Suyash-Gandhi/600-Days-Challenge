

# 1. Unsigned Integer ( uint )

 Represents non-negative integers only (≥ 0).
 By default,  uint  is the same as  uint256 .
 Can range from  0  to  2^256 - 1 .

Example:

 solidity
uint public age = 25;   // Stores positive whole numbers
 

✅ Use case: tracking balances, counters, timestamps.
⚠️ Avoid for values that can go negative.

---

# 2. Signed Integer ( int )

 Represents both positive and negative integers.
 By default,  int  is the same as  int256 .
 Range:  -2^255  to  2^255 - 1 .

Example:

 solidity
int public temperature = -15;  // Allows negative numbers
 

✅ Use case: cases where negative values are meaningful (e.g., profit/loss).
⚠️ Avoid when only positive values are required (gas optimization).

---

# 3. Boolean ( bool )

 Stores true or false values.
 Used for decision-making in conditions ( if ,  require , etc.).

Example:

 solidity
bool public isActive = true;   // Simple true/false flag
 

✅ Use case: enabling/disabling features, access control checks.
⚠️ Using multiple  bool  variables separately is gas-costly; better to pack them if many are needed.

---

# 4. String ( string )

 Stores textual data (UTF-8 encoded).
 Dynamic in size (no fixed length).
 More expensive in terms of gas compared to numbers.

Example:

 solidity
string public name = "Satoshi Nakamoto";
 

✅ Use case: metadata, names, messages.
⚠️ Avoid heavy string operations in smart contracts (better to store hashes or IDs).

---

# 5. Address ( address )

 Stores a 20-byte Ethereum address.
 Can represent an Externally Owned Account (EOA) or a Smart Contract.
 Comes in two forms:

    address  → basic (cannot send/receive Ether directly).
    address payable  → extended, allows sending Ether with  .transfer()  or  .send() .

Example:

 solidity
address public owner = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835c83;  

// Payable address
address payable public wallet = payable(owner);
 

✅ Use case: ownership, payments, contract interactions.
⚠️ Always check validity of addresses before transferring funds.
---

Q why is the address i got from these two different

function Address() public view returns(address) {

        return address(this) ;
    }
    
    function Addresss() public view returns(address) {

        return msg.sender ;
    }

 

---

## ⚙️ The Two Addresses You Got

| Function     | Returned Address                             | Meaning                                                                      |
| ------------ | -------------------------------------------- | ---------------------------------------------------------------------------- |
| `Address()`  | `0xf8e81D47203A594245E36C48e151709F0C19fBe8` | Contract address — where your smart contract is stored on the blockchain |
| `Addresss()` | `0x5B38Da6a701c568545dCfcB03FcB875f56beddC4` | Caller’s address — the Ethereum account that executed the function       |

---

## 🧩 Why They Are Different

### 1️⃣ `address(this)`

 `this` in Solidity refers to the current contract instance.
 Every time you deploy a contract, the Ethereum network assigns it a unique address.
 That’s where your contract’s code and storage live permanently.

So:
`address(this)` → `0xf8e81D47203A594245E36C48e151709F0C19fBe8`
means “this contract itself lives at that address”.

---

### 2️⃣ `msg.sender`

 `msg.sender` refers to who is calling the function.
 When you call the function from Remix, you’re using one of the test accounts provided (the “Account” dropdown in Remix).
 That is why it shows:
  `msg.sender = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4`
  which is your wallet/account in Remix.

---

### 🧠 Simple Analogy

Think of it like:

 `address(this)` → the shop’s address (the contract)
 `msg.sender` → the customer’s address (you calling it)

So of course they’re different — you and the shop are not the same person.

---

### ✅ Quick Test

Try this in Remix:

1. Go to the “Account” dropdown (top right in “Deploy & Run Transactions” panel).
2. Choose another account.
3. Call `Addresss()` again.

You’ll see a different `msg.sender`, but `address(this)` stays the same — because the contract doesn’t change, but the caller does.


---

 Comparison Table

| Type      | Range / Value    | Default Size   | Example Usage             |
| --------- | ---------------- | -------------- | ------------------------- |
|  uint     | 0 → 2^256-1      | 256 bits       | balances, counters        |
|  int      | -2^255 → 2^255-1 | 256 bits       | profit/loss, temperatures |
|  bool     | true/false       | 1 bit          | flags, conditions         |
|  string   | Dynamic UTF-8    | Variable       | names, metadata           |
|  address  | 20-byte hex      | Fixed 160 bits | accounts, contracts       |

---

 Best Practices

1. Use  uint  instead of  int  when negatives are not needed → saves gas.
2. Use  address payable  for Ether transfers, plain  address  otherwise.
3. Minimize string usage inside contracts (prefer storing hashes or IDs).
4. Keep booleans packed together in structs or mappings to save gas.

---
