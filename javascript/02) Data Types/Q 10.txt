Q10. How does type coercion work in JavaScript? Give examples 
where implicit conversion happens (e.g., "5" + 2, "5" - 2).

=> Type coercion is JavaScript’s automatic conversion of one 
data type to another when performing operations between values 
of different types.

It happens in two ways:

Implicit coercion → Done automatically by JavaScript.

Explicit coercion → Done manually by the developer (e.g., 
Number("5")).

Here we focus on implicit coercion.

Examples of Implicit Conversion
1. String Concatenation

If one operand is a string and the other is not, JavaScript 
converts the non-string to a string:

"5" + 2   // "52"  (number 2 is coerced into string "2")
2 + "5"   // "25"

2. Arithmetic Operations

For subtraction, multiplication, division, etc., JavaScript 
tries to convert operands to numbers:

"5" - 2   // 3   ("5" becomes 5)
"10" * "2" // 20  (both strings converted to numbers)
"20" / 5   // 4

3. Boolean Conversion in Conditionals

Values are coerced into boolean when used in logical contexts:

if ("hello") { console.log("Truthy!"); } // "hello" → true
if (0) { console.log("Won't run"); }     // 0 → false


Falsy values: 0, "", null, undefined, NaN, false.

Everything else is truthy.

4. Comparison with == (loose equality)

== allows coercion, === does not.

5 == "5"       // true   (string "5" converted to number 5)
0 == false     // true   (false converted to 0)
"" == false    // true   ("" converted to 0, false converted to 0)

5. Tricky Coercion Examples
[] + []         // ""   (empty array → empty string)
[] + {}         // "[object Object]" (array → "", object → string)
{} + []         // 0   ({} treated as block, +[] → 0)
[] == ![]       // true (explained in advanced section)


✅ In short:

+ → favors string concatenation if one operand is string.

Other arithmetic operators (-, *, /) → convert to numbers.

Logical/conditional → convert to boolean.

== → allows coercion, === does not.