

# 33. WeakSet and WeakMap 

WeakSet and WeakMap are special ES6 data structures designed for cases where you want to store objects weakly, meaning JavaScript's garbage collector can automatically remove them when they are no longer referenced anywhere in your program. They help manage memory efficiently, especially in large applications or when working with temporary objects.

---

# 1. What is WeakSet?

### Definition

A WeakSet is similar to a normal `Set`, but:

 It can only store objects, not primitives.
 It holds them weakly, meaning:

   If no other reference to the object exists, it is removed from the WeakSet automatically.
 It is not iterable (meaning you can’t loop over it).

### Why Weak?

The objects inside are not treated as strong references.
This avoids memory leaks.

---

## Key Characteristics of WeakSet

1. Stores only objects

   ```js
   const ws = new WeakSet();
   ws.add({ name: "A" }); // valid
   ws.add(10); // error
   ```

2. No iteration

    No `forEach`, no `for...of`.
    Cannot get its size.

3. Useful for tracking objects like DOM nodes, temporary caches, and marking things privately.

---

## Common WeakSet Methods

| Method        | Description                               |
| ------------- | ----------------------------------------- |
| `add(obj)`    | Adds an object                            |
| `has(obj)`    | Checks if the WeakSet contains the object |
| `delete(obj)` | Removes an object                         |

Example:

```js
const visited = new WeakSet();

function visit(node) {
  if (!visited.has(node)) {
    visited.add(node);
    console.log("Processing", node);
  }
}
```

---

# 2. What is WeakMap?

### Definition

A WeakMap is like a normal `Map`, except:

 Keys must be objects only.
 Keys are stored weakly.
 When an object key is no longer referenced anywhere else, the entry is removed automatically.

### Why WeakMap?

It is perfect for:

 Private data in classes
 Caching based on objects
 Storing metadata for DOM elements

---

## Key Characteristics of WeakMap

1. Keys are only objects, values can be anything
2. Not iterable (no keys(), values(), entries())
3. Automatic garbage collection
4. Prevents memory leaks in long-running apps

---

## Common WeakMap Methods

| Method            | Description              |
| ----------------- | ------------------------ |
| `set(key, value)` | Adds a value             |
| `get(key)`        | Retrieves the value      |
| `has(key)`        | Checks if the key exists |
| `delete(key)`     | Removes the entry        |

Example:

```js
const privateData = new WeakMap();

class User {
  constructor(name, age) {
    privateData.set(this, { age });
    this.name = name;
  }

  getAge() {
    return privateData.get(this).age;
  }
}

const u1 = new User("Suyash", 22);
console.log(u1.getAge());
```

This pattern stores private data that cannot be accessed from outside.

---

# 3. Differences Between Set/Map and WeakSet/WeakMap

### Set vs WeakSet

 Set can store primitives; WeakSet cannot.
 Set is iterable; WeakSet is not.
 WeakSet allows garbage collection; Set does not.

### Map vs WeakMap

 Map keys can be anything; WeakMap keys must be objects.
 Map is iterable; WeakMap isn’t.
 WeakMap supports automatic memory cleanup.

---

# 4. When to Use WeakSet

 Marking or tagging objects without affecting memory.
 Tracking visited objects in graph algorithms.
 Holding DOM nodes temporarily.

Example:

```js
const selectedNodes = new WeakSet();
selectedNodes.add(document.querySelector("div"));
```

---

# 5. When to Use WeakMap

 Implementing truly private class fields.
 Caching results of expensive computations.
 Storing metadata for objects without preventing garbage collection.

Example:

```js
const cache = new WeakMap();

function compute(obj) {
  if (!cache.has(obj)) {
    cache.set(obj, expensiveCalculation(obj));
  }
  return cache.get(obj);
}
```

