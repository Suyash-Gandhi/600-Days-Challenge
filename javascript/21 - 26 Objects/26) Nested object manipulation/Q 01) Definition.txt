

# 26. Nested Object Manipulation in JavaScript (≈1500 tokens)


# 2. What Are Nested Objects?

A nested object is simply:

```js
const user = {
  name: "Alex",
  address: {
    city: "Mumbai",
    location: {
      lat: 19.07,
      lng: 72.87
    }
  }
};
```

Here:

 `user.address` → object inside `user`
 `user.address.location` → deeper nested object

Such structures allow representing hierarchical data.

---

# 3. Accessing Nested Object Properties

## 3.1 Dot Notation

```js
console.log(user.address.city);        // Mumbai
console.log(user.address.location.lat); // 19.07
```

This is the most common approach.

---

## 3.2 Bracket Notation

Needed when:

 Keys contain spaces
 Keys start with numbers
 Keys stored in variables

Example:

```js
const key = "city";
console.log(user["address"][key]);   // Mumbai
```

---

## 3.3 Optional Chaining (`?.`)

Prevents runtime errors like:
"Cannot read property 'city' of undefined"

Example:

```js
console.log(user.address?.location?.lat);
```

If any part is missing → returns `undefined` instead of crashing.

Why it matters:
API responses may not always have the full structure. Optional chaining makes your code safe.

---

# 4. Updating Nested Object Properties

This is where beginners struggle because updating deep properties may:

 Create new nested keys
 Require cloning (in React)
 Modify references unintentionally

## 4.1 Simple Update

```js
user.address.city = "Delhi";
```

---

## 4.2 Updating Deep Keys That May Not Exist

If keys don’t exist, JS normally throws errors.
Solution → create missing levels:

```js
user.profile = user.profile || {};
user.profile.bio = "Student";
```

Another approach using ES2020:

```js
user.profile ??= {};
user.profile.bio = "Student";
```

---

## 4.3 Updating Using Dynamic Keys

```js
const keyPath = ["address", "location", "lat"];

let ref = user;
keyPath.slice(0, -1).forEach(k => {
  if (!ref[k]) ref[k] = {};
  ref = ref[k];
});

ref[keyPath[keyPath.length - 1]] = 20.55;
```

This is common in form builders, JSON editors.

---

# 5. Creating / Adding Values Deep Inside Nested Objects

## 5.1 Manual creation

```js
user.settings = {
  notifications: {
    sms: true
  }
};
```

---

## 5.2 Safely Creating Deep Paths

Reusable helper:

```js
const createPath = (obj, path, value) => {
  let ref = obj;
  path.slice(0, -1).forEach(key => {
    if (!ref[key]) ref[key] = {};
    ref = ref[key];
  });
  ref[path[path.length - 1]] = value;
};

createPath(user, ["preferences", "color", "theme"], "dark");
```

Now `user.preferences.color.theme === "dark"`.

---

# 6. Deleting Nested Properties

## 6.1 Using `delete`

```js
delete user.address.location.lng;
```

But this doesn’t delete empty objects, meaning structure remains:

```
address.location = { lat: 19.07 }
```

---

## 6.2 Removing Deep Keys Safely

Use a helper function:

```js
const deletePath = (obj, path) => {
  let ref = obj;
  path.slice(0, -1).forEach(k => {
    if (!ref[k]) return;
    ref = ref[k];
  });
  delete ref[path[path.length - 1]];
};

deletePath(user, ["address", "location", "lat"]);
```

---

# 7. Nested Object Traversal (Looping)

Sometimes you need to:

 Search keys
 Modify multiple levels
 Count values
 Find deeply nested items

## 7.1 Using `for...in` (shallow)

```js
for (let key in user.address) {
  console.log(key);
}
```

---

## 7.2 Deep Traversal with Recursion

Recursion is the ultimate tool for nested structures.

Example: print all keys in nested object:

```js
const printKeys = (obj) => {
  for (let key in obj) {
    console.log(key);
    if (typeof obj[key] === "object" && obj[key] !== null) {
      printKeys(obj[key]);
    }
  }
};

printKeys(user);
```

Used in:

 JSON renderers
 Form generators
 MongoDB document explorers

---

# 8. Nested Object Destructuring

Destructuring helps extract deeply nested values cleanly.

## 8.1 Basic Example

```js
const { address: { city } } = user;
console.log(city);  // Mumbai
```

---

## 8.2 Extracting multiple nested values

```js
const {
  address: {
    location: { lat, lng }
  }
} = user;
```

---

## 8.3 Using default values

```js
const {
  address: {
    pincode = 400001
  }
} = user;
```

Helps avoid undefined values.

---

# 9. Nested Object Manipulation With Immutability (React Focus)

In React, you must never mutate nested objects directly.

❌ Wrong:

```js
state.user.address.city = "Delhi";
```

✔ Correct (clone objects using spread):

```js
setState(prev => ({
  ...prev,
  user: {
    ...prev.user,
    address: {
      ...prev.user.address,
      city: "Delhi"
    }
  }
}));
```

Important: Spread does shallow cloning only.
For very deep objects → use:

 `structuredClone`
 `JSON.parse(JSON.stringify(obj))` (not recommended for dates, functions)
 a recursive deep clone function

---

# 10. Checking Existence of Nested Keys

## 10.1 Using `in` operator

```js
"city" in user.address; // true
```

---

## 10.2 Using optional chaining

```js
if (user.address?.location?.lat) {
  console.log("Latitude exists");
}
```

---

## 10.3 Using `hasOwnProperty`

```js
user.address.hasOwnProperty("city");
```

---

# 11. Flattening and Unflattening Nested Objects

## 11.1 Flatten nested object → `{ "a.b.c": value }`

Useful for:

 Storing form data
 Sending API payloads
 Updating MongoDB using dot notation

Example:

```js
const flatten = (obj, parent = "", res = {}) => {
  for (let key in obj) {
    const path = parent ? parent + "." + key : key;
    if (typeof obj[key] === "object" && obj[key] !== null) {
      flatten(obj[key], path, res);
    } else {
      res[path] = obj[key];
    }
  }
  return res;
};
```

---

## 11.2 Convert flat object → nested

```js
const unflatten = (obj) => {
  const result = {};
  for (let key in obj) {
    const parts = key.split(".");
    createPath(result, parts, obj[key]);
  }
  return result;
};
```

---
