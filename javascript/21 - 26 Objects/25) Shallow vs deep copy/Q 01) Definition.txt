
# üß† 25. Shallow vs Deep Copy in JavaScript ‚Äî Complete Explanation


# üîπ 1. How JavaScript Stores Values (Why Copying Is Complicated)

JavaScript has two categories of values:

### 1. Primitive values (copied by value):

 number
 string
 boolean
 null
 undefined
 bigInt
 symbol

When you copy a primitive:

```js
let a = 10;
let b = a;  
b = 20;
```

Changes to `b` do not affect `a`. No magic here.

### 2. Reference values (copied by reference):

 objects
 arrays
 functions
 dates
 maps/sets
 custom class instances

When you copy a reference value:

```js
let obj1 = { x: 1 };
let obj2 = obj1; // same memory reference
obj2.x = 99;
```

Now obj1.x becomes 99, because both point to the same place in memory.

This is why shallow vs deep copying matters.

---

# üü¶ 2. What Is Shallow Copy? (Definition + Examples)

### ‚úî Definition (Simple and Core Idea)

A shallow copy creates a new outer object, but inner nested objects are still references to the original.

Think of it like:

```
outer object = new box
nested objects = same old items inside
```

### ‚úî What shallow copy does copy

 first-level properties
 new shell (container object)

### ‚úî What shallow copy does NOT copy

 nested objects (they remain shared)
 nested arrays
 nested maps/sets
 functions inside objects (references remain same)

---

## üü¶ 2.1 Ways to Make a Shallow Copy

### 1. Spread Operator (`...`)

```js
const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { ...obj1 };

obj2.b.c = 99;

console.log(obj1.b.c); // 99 ‚Üí still linked
```

### 2. `Object.assign()`

```js
const obj2 = Object.assign({}, obj1);
```

Again, nested levels remain shared.

### 3. For Arrays ‚Äì Spread & slice

```js
const arr1 = [1, 2, [3, 4]];
const arr2 = [...arr1];

arr2[2][0] = 999;

console.log(arr1[2][0]); // 999
```

### ‚úî Conclusion:

Shallow copying breaks only the first level.

---

# üü• 3. What Is Deep Copy? (Definition + Key Properties)

### ‚úî Definition

A deep copy makes a fully independent clone, including all nested objects, arrays, and values.

Nothing is shared.
Every level is copied recursively.

```
outer object = new box
nested objects = also new boxes
all contents = new copies
```

### ‚úî Deep copying ensures:

 modifying the copy does not affect the original
 modifying the original does not affect the copy
 memory pointers are completely different

This is what you need in React, Redux, MERN stack, or any functional programming scenario.

---

# üî• 4. Ways to Do Deep Copy (with comparisons)

## 4.1 `structuredClone()` ‚Äî The Best Modern Deep Copy Method

Introduced in modern JavaScript.

### ‚úî Why it's great:

 native
 fast
 supports almost all data types
 handles circular references
 stable and reliable

### ‚úî Example:

```js
const obj1 = {
  a: 1,
  b: { c: 2 },
  d: [3, 4],
};

const obj2 = structuredClone(obj1);

obj2.b.c = 99;

console.log(obj1.b.c); // still 2 ‚Üí fully independent
```

### ‚úî Supports:

 Object
 Array
 Maps
 Sets
 Date
 RegExp
 Typed arrays
 ArrayBuffer
 Circular references

### ‚úî Does not support:

 Functions
 Classes with methods
 DOM nodes

---

## 4.2 JSON Methods (Old but Famous)

Many juniors use this:

```js
const deepCopy = JSON.parse(JSON.stringify(obj));
```

### ‚úî Advantages:

 simple
 works for simple objects

### ‚ùå Limitations (Important Interview Points):

 drops functions
 drops undefined
 drops NaN, Infinity
 drops Date objects
 fails on Map/Set
 fails on circular references (crashes)
 may cause performance problems for large objects

This is why `structuredClone()` is better.

---

## 4.3 Recursive Deep Copy (Manual)

Interviewers often ask:

> ‚ÄúHow would you implement your own deep copy function?‚Äù

Here is the clean ES6 version:

```js
const deepCopy = (value) => {
  if (typeof value !== "object" || value === null) {
    return value; // primitive
  }

  if (Array.isArray(value)) {
    return value.map(item => deepCopy(item));
  }

  const copy = {};
  for (const key in value) {
    copy[key] = deepCopy(value[key]);
  }

  return copy;
};
```

### ‚úî Features:

 works for nested objects
 works for arrays

### ‚ùå Cannot handle:

 Date
 Map/Set
 RegExp
 circular references
 special objects

### üß† Why learn this?

 interviewers test your recursion understanding
 shows mastery of references & JS memory model
 required for writing polyfills

---

## 4.4 Using Libraries

### Lodash (`_.cloneDeep`)

```js
const _ = require("lodash");
const obj2 = _.cloneDeep(obj1);
```

### ‚úî Pros:

 stable
 handles many edge cases
 widely used in production
 perfect for React/Redux state cloning

### ‚ùå Cons:

 adds dependency
 slower than structuredClone
 doesn't support circular references well

---
