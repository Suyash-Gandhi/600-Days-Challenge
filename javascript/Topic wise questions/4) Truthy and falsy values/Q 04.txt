Q4. How do wrapper objects (e.g., new Boolean(false)) behave in 
conditional checks compared to primitive boolean values?

=> In JavaScript, values can either be primitives (basic 
immutable data types like boolean, string, number, etc.) or 
objects (instances created using constructors such as new 
Boolean(), new Number(), etc.).

This distinction is crucial in conditional checks, because 
objects in JavaScript are always considered truthy, regardless 
of the internal value they wrap.

2. Primitive Boolean Values

A primitive boolean is either true or false.

They behave predictably in conditional statements:

if (false) {
  console.log("Will not run"); 
}
if (true) {
  console.log("Will run"); 
}


Here, the evaluation is direct, and the condition respects the 
actual boolean value.

3. Wrapper Boolean Objects

A wrapper object is created using the Boolean constructor:

let x = new Boolean(false);


Even though it wraps the primitive false, the object itself is 
truthy.

In a conditional check:

if (new Boolean(false)) {
  console.log("This will run"); // âœ… Runs
}


This happens because JavaScript does not look inside the 
object for its internal boolean value. Instead, it only 
evaluates the object reference itself, and all objects are 
truthy by default.

4. Common Pitfalls

Developers might assume that new Boolean(false) behaves like 
primitive false.

This can lead to unexpected logic errors:

let isActive = new Boolean(false);
if (isActive) {
  console.log("Still considered active!"); // Misleading
}


Such code misbehaves because the wrapper object itself is truthy.