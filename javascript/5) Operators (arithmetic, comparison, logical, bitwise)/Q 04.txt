Q4. Why do we need bitwise shift operators (<< and >>) if we 
already have normal multiplication and division?


=> 1. Basic Concept

Normal multiplication (*) and division (/) work at the 
arithmetic level, directly calculating values.

Bitwise shift operators (<< for left shift, >> for right shift) 
manipulate the binary representation of numbers, effectively 
multiplying or dividing by powers of 2.

For example:

5 << 1 → 101 (binary) becomes 1010 → result is 10 (equivalent 
to 5 * 2).

20 >> 2 → 10100 becomes 101 → result is 5 (equivalent to 20 / 4).

2. Performance Considerations

Historically, bitwise shifts were faster than multiplication/
division on low-level CPUs because shifting bits is a simpler 
operation.

In modern JavaScript engines, the performance difference is 
negligible since compilers optimize multiplications/divisions 
into shifts when applicable.

But in embedded systems, game engines, or cryptographic 
algorithms, shifts are still preferred when maximum performance 
is required.

3. Control over Bits

Shifts are not just “faster multiply/divide.”

They give precise control over binary digits, which normal 
multiplication/division does not provide.

Example:

let mask = 1 << 3; // 8


This creates a bitmask to check or set the 4th bit of a binary 
number.

Without shifts, creating masks would be clumsy and slow.

4. Special Use Cases

Bitmasking & Flags – Managing on/off states in a compact form.

let READ = 1 << 0;  // 0001
let WRITE = 1 << 1; // 0010
let EXEC = 1 << 2;  // 0100


Low-level protocols – Packing and unpacking data in networking 
or hardware.

Hashing & Cryptography – Shifts are part of many hash functions 
(e.g., SHA, MD5).

Graphics & Game Development – Fast calculations for coordinates, 
colors, etc.