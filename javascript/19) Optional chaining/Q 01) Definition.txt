### 🔹 Optional Chaining in JavaScript

Optional chaining (`?.`) is a safe way to access deeply nested object properties without worrying about whether an intermediate property exists.
If any part of the chain is `null` or `undefined`, it stops and returns `undefined` instead of throwing an error.

---

### 🔸 1. Problem Without Optional Chaining

Let’s say you have this object:

```js
const user = {
  profile: {
    name: 'Suyash',
    address: {
      city: 'Mumbai'
    }
  }
};
```

Now, if you try to access a deeply nested property like this:

```js
console.log(user.profile.address.city); // ✅ "Mumbai"
console.log(user.profile.contact.phone); // ❌ Error: Cannot read properties of undefined
```

The second line throws an error because `contact` doesn’t exist.

---

### 🔸 2. Solution: Using Optional Chaining (`?.`)

```js
console.log(user.profile?.address?.city);    // "Mumbai"
console.log(user.profile?.contact?.phone);   // undefined (no error)
```

Here’s what happens:

 The `?.` operator checks if the value before it is null or undefined.
 If it is, the expression stops and returns `undefined` instead of throwing an error.

---

### 🔸 3. Syntax Overview

| Type                | Example              | Description                        |
| ------------------- | -------------------- | ---------------------------------- |
| Property access | `obj?.prop`          | Safely access `obj.prop`           |
| Nested property | `obj?.prop?.subProp` | Safe chain of properties           |
| Method call     | `obj.method?.()`     | Calls `method()` only if it exists |
| Array element   | `arr?.[index]`       | Access array element safely        |

---

### 🔸 4. Examples

#### ✅ Accessing nested properties

```js
const user = {};
console.log(user.profile?.name); // undefined (no error)
```

#### ✅ Calling optional methods

```js
const user = {
  greet() { return 'Hello!'; }
};

console.log(user.greet?.()); // "Hello!"
console.log(user.sayHi?.()); // undefined (no error)
```

#### ✅ Accessing array items safely

```js
const users = null;
console.log(users?.[0]); // undefined
```

---

### 🔸 5. Combining with Nullish Coalescing (`??`)

You can combine optional chaining with nullish coalescing to provide default values.

```js
const user = { profile: null };

const city = user.profile?.address?.city ?? 'Unknown';
console.log(city); // "Unknown"
```

---

### 🔸 6. Key Points & Best Practices

 ✅ Prevents runtime errors when accessing nested properties.
 ✅ Returns `undefined` instead of throwing.
 ⚠️ Use only when you expect possible null/undefined values.
 ⚠️ Don’t overuse it — if a property should always exist, rely on normal access to catch mistakes early.

---

### 🔸 7. Real-World Example

When working with API responses:

```js
fetch('/user')
  .then(res => res.json())
  .then(data => {
    console.log(data?.profile?.email ?? 'Email not available');
  });
```

If any part of the chain is missing, the code won’t crash — it’ll safely return `undefined`.

---

### ✅ In Short

| Feature    | Description                                   |
| ---------- | --------------------------------------------- |
| Operator   | `?.`                                          |
| Purpose    | Safely access nested properties               |
| Returns    | `undefined` if value is `null` or `undefined` |
| Common Use | Objects, arrays, methods                      |
| Works With | Nullish coalescing (`??`) for defaults        |

