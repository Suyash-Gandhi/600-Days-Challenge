
---

# 30. Flattening Nested Arrays in JavaScript (`flat`, recursion, reduce`)

Flattening nested arrays is a common task in JavaScript, especially when handling deeply structured data such as API responses, directory trees, or multi-level configurations. It refers to the process of converting a nested array (array inside array) into a single-level array containing all the elements in order.

This topic is critical because real-world data is very rarely flat. Understanding `flat()`, recursion, and `reduce()` gives you strong control over data transformations, functional programming techniques, and algorithmic thinking.

---

# 1. What Is Flattening?

### Definition

Flattening means taking something like:

```js
const arr = [1, [2, 3], [4, [5, 6]]];
```

And converting it to:

```js
[1, 2, 3, 4, 5, 6]
```

### Why do we need flattening?

 To simplify complex data structures
 To make array elements directly searchable
 To avoid multi-level loops
 To improve readability and function composition
 Many algorithms (mapping, sorting, filtering) work better on flat data

---

# 2. Flattening Using `Array.prototype.flat()`

`flat()` is the simplest approach and the one most commonly used in modern JavaScript.

---

## 2.1 Basic Syntax

```js
array.flat(depth)
```

### Parameters

 depth: How many levels deep to flatten

   Default is 1
   You can pass `Infinity` to flatten arbitrarily deep

---

## 2.2 Example 1 — Flatten One Level

```js
const arr = [1, [2, 3]];
console.log(arr.flat());
// [1, 2, 3]
```

Only the outermost level is flattened.

---

## 2.3 Example 2 — Flatten Multiple Levels

```js
const arr = [1, [2, [3, [4]]]];
console.log(arr.flat(2));
// [1, 2, 3, [4]]
```

---

## 2.4 Example 3 — Flatten Completely with `Infinity`

```js
const arr = [1, [2, [3, [4]]]];
console.log(arr.flat(Infinity));
// [1, 2, 3, 4]
```

### When to use `flat()`

 When you know the data structure
 When depth is predictable
 When you want the simplest and fastest method

---

# 3. Flattening Using Recursion

Before JavaScript introduced `flat`, recursion was the standard approach. It still matters because:

 Interviews expect recursive reasoning
 Many custom flattening operations require recursion
 You often need more control than `flat()` offers

Recursion works by checking each element:

 If it’s a primitive → push it
 If it’s an array → recursively flatten it

---

## 3.1 Standard Recursive Approach

```js
const flatten = (arr) => {
  let result = [];

  arr.forEach(item => {
    if (Array.isArray(item)) {
      result = result.concat(flatten(item));  // recursive call
    } else {
      result.push(item);
    }
  });

  return result;
};
```

---

## 3.2 Example

```js
flatten([1, [2, [3, 4], 5], 6]);
// Output: [1, 2, 3, 4, 5, 6]
```

### Step-by-step explanation

1. Loop through array
2. If element is an array → flatten further
3. If element is a value → add to result
4. Continue until no nested arrays remain
5. Return the accumulated array

---

## 3.3 Why recursion is important

 It matches the conceptual definition of flattening
 Works for arbitrarily deep nests
 You can extend logic (e.g., skip values, filter, transform)
 Excellent for understanding tree-like structures

---

# 4. Flattening Using `reduce()`

`reduce()` is more functional and elegant. It's often used in interview problems because it demonstrates strong understanding of higher-order array functions.

---

## 4.1 Basic Reduce-Based Implementation

```js
const flatten = (arr) => {
  return arr.reduce((acc, item) => {
    return Array.isArray(item)
      ? acc.concat(flatten(item))
      : acc.concat(item);
  }, []);
};
```

---

## 4.2 How it works

 `reduce()` iterates over array
 `acc` is the running flattened result
 If `item` is an array → recursively flatten and concat
 Else → concat the value
 Returns the completely flattened array

---

## 4.3 Example

```js
flatten([1, [2, [3, 4]], 5]);
// Output: [1, 2, 3, 4, 5]
```

---

# 5. Comparing `flat()`, Recursion, and `reduce()`

A clear comparison helps you pick the right method depending on your use-case or interview scenario.

---

## 5.1 Ease of use

| Method     | Difficulty | When to Use                               |
| ---------- | ---------- | ----------------------------------------- |
| `flat()`   | Easiest    | Modern code, simple tasks                 |
| Recursion  | Medium     | Algorithms, interviews, custom flattening |
| `reduce()` | High       | Functional programming, showcasing skills |

---

## 5.2 Control and Flexibility

 `flat()`: Works fast but limited to flattening only
 Recursion: Most control, can modify or filter during flattening
 `reduce()`: Combines traversal + accumulation elegantly

---

## 5.3 Performance

 `flat()` is highly optimized in modern JS engines
 Recursion may hit call stack limits if extremely deep
 `reduce()` is slower than `flat()` but fine for most real uses

---

# 6. Custom Flattening Requirements

Real-world data often requires more than simple flattening. Examples include:

---

## 6.1 Flattening Arrays but Keeping Certain Types Intact

Example: flatten only numeric levels but keep objects as they are.

```js
const customFlatten = (arr) => {
  return arr.reduce((acc, item) => {
    if (Array.isArray(item)) {
      return acc.concat(customFlatten(item));
    }
    return acc.concat(item);
  }, []);
};
```

---

## 6.2 Flatten Up to a Certain Depth (Custom Depth)

Equivalent to `flat(depth)` but using recursion:

```js
const flattenDepth = (arr, depth = 1) => {
  if (depth === 0) return arr;

  return arr.reduce((acc, item) => {
    if (Array.isArray(item)) {
      return acc.concat(flattenDepth(item, depth - 1));
    }
    return acc.concat(item);
  }, []);
};
```

---

## 6.3 Skip Certain Elements During Flattening

Example: skip `null` and `undefined`:

```js
const flattenSkip = (arr) => {
  return arr.reduce((acc, item) => {
    if (item == null) return acc;       // skip null/undefined

    if (Array.isArray(item)) {
      return acc.concat(flattenSkip(item));
    }
    return acc.concat(item);
  }, []);
};
```

---

