Q5. Can a value be falsy in one context but truthy in another? 
Provide examples.

=> In JavaScript, a value’s evaluation depends on the context 
in which it is used. The same value can behave as falsy in one
 situation but appear truthy in another, due to type coercion 
 rules and object vs. primitive distinctions.

2. Definition of Falsy and Truthy

Falsy values: false, 0, -0, 0n, "", null, undefined, NaN.

Truthy values: All other values, including non-empty strings, 
numbers other than zero, arrays, objects, and functions.

However, coercion and context can make a value shift its 
perceived truthiness.

3. Example 1: Empty String in Different Contexts

if ("") console.log("Runs");    // ❌ Doesn't run ("" is falsy)

console.log("" == 0);  // ✅ true, because "" → 0 during numeric coercion

Here, "" is falsy in a Boolean context.

But in a loose equality check (==), it is coerced to 0, which 
equals 0.

4. Example 2: Array in Boolean vs Equality Context
if ([]) console.log("Truthy"); // ✅ Runs (arrays are objects → truthy)

console.log([] == false) // ✅ true, because [] → "" → 0 during coercion


In a Boolean check, [] is truthy.

But in == comparison with false, coercion makes it behave like 
false.

5. Example 3: Boolean Wrapper Object
let val = new Boolean(false);

if (val) console.log("Truthy"); // ✅ Runs (objects are always truthy)
console.log(val.valueOf());// ❌ false (primitive value inside)


As an object, new Boolean(false) is truthy.

But when you extract its primitive with .valueOf(), it becomes 
falsy.

6. Example 4: null and undefined in Equality Checks
console.log(null == undefined);   // ✅ true (special loose 
equality rule)
if (null) console.log("Runs"); // ❌ Doesn't run (null is falsy)


null is falsy in Boolean context.

But it is loosely equal to undefined.

7. Common Pitfalls

Developers mistakenly assume values behave consistently across 
contexts.

For example:

if ([] == false) console.log("Confusing"); // Runs
if ([]) console.log("Also confusing");     // Runs too, but for opposite reason


This inconsistency can lead to hard-to-debug logical errors.