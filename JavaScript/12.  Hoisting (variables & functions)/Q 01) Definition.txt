
## ğŸ§  1. What is Hoisting?

Definition:
Hoisting is JavaScriptâ€™s default behavior of moving declarations (not initializations) to the top of their scope (either global or function scope) during the compilation phase.

In simple terms â€” before your code runs, JS scans it and â€œliftsâ€ variable and function declarations to the top of the scope, allowing you to use them before theyâ€™re actually written in the code.

---

## âš™ï¸ 2. How Hoisting Works (Behind the Scenes)

Before executing code, JS performs two steps:

1. Memory creation phase (compile time):

    JS engine allocates memory for variables and functions.
    Variables declared with `var` are set to undefined.
    Functions declared with `function` keyword are stored entirely (their whole definition is hoisted).

2. Execution phase:

    The code runs line-by-line, using those memory references.

---

## ğŸ§© 3. Variable Hoisting

### ğŸŸ  `var` Hoisting

`var` declarations are hoisted and initialized with `undefined`.

Example:

```js
console.log(a); // undefined
var a = 10;
```

Explanation:
Internally, JavaScript treats it like:

```js
var a;      // declaration hoisted
console.log(a); // undefined
a = 10;     // initialization happens later
```

So the declaration is hoisted, but the assignment remains in place.

---

### ğŸ”µ `let` and `const` Hoisting

Both `let` and `const` are also hoisted, but they are not initialized until the code execution reaches their line.
They exist in the Temporal Dead Zone (TDZ) â€” a period between the start of the scope and their actual declaration line, where access causes an error.

Example:

```js
console.log(x); // âŒ ReferenceError: Cannot access 'x' before initialization
let x = 5;
```

Explanation:

 The declaration is hoisted (JS knows `x` exists),
 but it isnâ€™t initialized yet, so it canâ€™t be accessed.

---

### ğŸ§  Summary Table for Variable Hoisting

| Keyword | Hoisted? | Initialized before use? | Default Value | Accessible before declaration? |
| ------- | -------- | ----------------------- | ------------- | ------------------------------ |
| `var`   | âœ… Yes    | âœ… Yes (as undefined)    | `undefined`   | âœ… Yes                          |
| `let`   | âœ… Yes    | âŒ No                    | â€”             | âŒ No (TDZ)                     |
| `const` | âœ… Yes    | âŒ No                    | â€”             | âŒ No (TDZ)                     |

---

## ğŸ§­ 4. Function Hoisting

### ğŸŸ¢ Function Declarations

Functions defined using the `function` keyword are fully hoisted â€” meaning both their name and definition are hoisted to the top of the scope.

Example:

```js
greet(); // âœ… Works fine
function greet() {
  console.log("Hello!");
}
```

Internally, JS treats it as if the function is available from the start of the scope.

---

### ğŸŸ£ Function Expressions (with `var`, `let`, `const`)

If you assign a function to a variable, only the variable declaration is hoisted â€” not the function definition.

Example:

```js
sayHello(); // âŒ TypeError: sayHello is not a function
var sayHello = function() {
  console.log("Hi!");
};
```

Explanation:

```js
var sayHello;        // declaration hoisted
sayHello();          // âŒ undefined()
sayHello = function() { console.log("Hi!"); };
```

For `let` or `const`, itâ€™s even stricter:

```js
sayHello(); // âŒ ReferenceError
let sayHello = function() {
  console.log("Hi!");
};
```

---

## ğŸ§® 5. Hoisting with Arrow Functions

Arrow functions behave like function expressions, not declarations.
So they follow the same hoisting rules as the variable type they are assigned to.

Example:

```js
greet(); // âŒ ReferenceError
const greet = () => console.log("Hey there!");
```

---

## ğŸ§© 6. Real-World Example

```js
console.log(a); // undefined
var a = 10;

foo(); // works
function foo() {
  console.log("Function is hoisted!");
}

bar(); // âŒ TypeError: bar is not a function
var bar = function() {
  console.log("This won't run yet");
};
```

Step-by-step Explanation:

During memory creation phase:

```js
var a = undefined;
function foo() { ... }
var bar = undefined;
```

During execution:

1. `console.log(a)` â†’ `undefined`
2. `foo()` â†’ prints message
3. `bar()` â†’ `undefined is not a function` (since itâ€™s not assigned yet)

---

## ğŸ” 7. Key Takeaways

| Type                  | What Gets Hoisted         | Can You Use It Before Declaration? | Notes                    |
| --------------------- | ------------------------- | ---------------------------------- | ------------------------ |
| `var`                 | Declaration only          | Yes, gives `undefined`             | Function-scope           |
| `let` / `const`       | Declaration only (in TDZ) | No                                 | Block-scope              |
| `function`            | Declaration + Definition  | Yes                                | Fully hoisted            |
| `function expression` | Variable declaration only | No                                 | Depends on var/let/const |
| `arrow function`      | Variable declaration only | No                                 | Same as let/const rules  |

---

## ğŸ§  8. Interview Tip

If youâ€™re asked â€œIs hoisting bad?â€ â€”
ğŸ‘‰ Not really. Itâ€™s just how JS works internally.
But relying on hoisting makes code confusing.
âœ… Best practice: Always declare variables and functions before using them.

