## 45. Generators (`function`, `yield`) in JavaScript

Generators are a special kind of function that can pause and resume execution. Unlike normal functions (which run from start to finish in one go), generators let you produce values step by step, only when they are needed.

They are extremely useful when dealing with:

 Large or infinite data sequences
 Lazy evaluation
 Custom iteration logic
 Controlling asynchronous flows (historically, before `async/await`)

---

## 1. What is a Generator?

A generator is a function declared using `function` and uses the `yield` keyword instead of `return`.

 `yield` pauses the function
 The function remembers its state
 Calling `.next()` resumes execution from where it stopped

üëâ Think of a generator as a pause‚Äìresume machine.

---

## 2. Basic Syntax

```js
function* myGenerator() {
  yield 1;
  yield 2;
  yield 3;
}
```

Calling the generator does not execute it immediately.

```js
const gen = myGenerator();
```

Execution starts only when `.next()` is called.

---

## 3. How `.next()` Works

Each call to `.next()` returns an object:

```js
{ value: any, done: boolean }
```

Example:

```js
const gen = myGenerator();

gen.next(); // { value: 1, done: false }
gen.next(); // { value: 2, done: false }
gen.next(); // { value: 3, done: false }
gen.next(); // { value: undefined, done: true }
```

### Key observations:

 `value` ‚Üí value yielded
 `done` ‚Üí `true` when generator is finished
 After `done: true`, further `.next()` calls do nothing

---

## 4. `yield` vs `return`

| Feature          | `yield` | `return` |
| ---------------- | ------- | -------- |
| Pauses function  | ‚úÖ Yes   | ‚ùå No     |
| Can resume later | ‚úÖ Yes   | ‚ùå No     |
| Ends generator   | ‚ùå No    | ‚úÖ Yes    |
| Multiple values  | ‚úÖ Yes   | ‚ùå No     |

Example:

```js
function* test() {
  yield "A";
  return "B";
  yield "C"; // never executed
}
```

---

## 5. Generator Execution Flow (Step-by-Step)

```js
function* demo() {
  console.log("Start");
  yield 1;

  console.log("Middle");
  yield 2;

  console.log("End");
}
```

```js
const gen = demo();

gen.next(); // logs "Start", returns { value: 1, done: false }
gen.next(); // logs "Middle", returns { value: 2, done: false }
gen.next(); // logs "End", returns { value: undefined, done: true }
```

üëâ Code runs only until the next `yield`.

---

## 6. Passing Values into `yield`

You can send values back into the generator using `.next(value)`.

```js
function* calculator() {
  const x = yield "Enter first number";
  const y = yield "Enter second number";
  return x + y;
}

const gen = calculator();

gen.next();        // { value: "Enter first number", done: false }
gen.next(10);      // { value: "Enter second number", done: false }
gen.next(20);      // { value: 30, done: true }
```

### Important rule:

 The value passed to `.next(value)` becomes the result of the previous `yield`

---

## 7. Generators as Iterators

Generators automatically implement the iterator protocol, so they work with `for...of`.

```js
function* numbers() {
  yield 1;
  yield 2;
  yield 3;
}

for (const num of numbers()) {
  console.log(num);
}
```

Output:

```
1
2
3
```

Why this matters:

 No need to manually implement `Symbol.iterator`
 Clean and readable iteration logic

---

## 8. Infinite Sequences (Lazy Evaluation)

Generators shine when dealing with infinite or very large sequences.

```js
function* infiniteCounter() {
  let i = 1;
  while (true) {
    yield i++;
  }
}

const counter = infiniteCounter();

counter.next().value; // 1
counter.next().value; // 2
counter.next().value; // 3
```

üëâ Values are generated only when requested, not all at once.

---

## 9. Delegating with `yield`

`yield` allows one generator to delegate to another generator.

```js
function* genA() {
  yield 1;
  yield 2;
}

function genB() {
  yield 3;
  yield* genA();
  yield 4;
}
```

```js
[...genB()]; // [3, 1, 2, 4]
```

Use cases:

 Composing generators
 Reusing iteration logic
 Cleaner modular code

---

## 10. Generators vs Normal Functions

| Aspect          | Normal Function | Generator        |
| --------------- | --------------- | ---------------- |
| Execution       | Runs fully      | Pauses & resumes |
| Returns         | Single value    | Multiple values  |
| State memory    | ‚ùå No            | ‚úÖ Yes            |
| Iteration       | Manual          | Built-in         |
| Lazy evaluation | ‚ùå No            | ‚úÖ Yes            |

---

## 11. Generators vs `async/await`

| Feature              | Generators    | `async/await` |
| -------------------- | ------------- | ------------- |
| Introduced for async | Yes (earlier) | Yes (modern)  |
| Complexity           | Higher        | Lower         |
| Async handling       | Manual        | Automatic     |
| Promise handling     | Explicit      | Implicit      |
| Current usage        | Niche         | Standard      |

üëâ Today, generators are mostly used for:

 Custom iterators
 Lazy data processing
 Libraries and frameworks
 Advanced control flows

---

## 12. Real-World Use Cases

1. Custom iterators
2. Lazy loading large datasets
3. Streaming data
4. State machines
5. Controlled async flows (historical)
6. Parsing and tokenization

---

## 13. When NOT to Use Generators

Avoid generators when:

 Simple loops are enough
 You need straightforward async logic (`async/await` is better)
 Code readability is more important than control

Generators are powerful‚Äîbut overkill for simple tasks.

---

## 14. Key Takeaways

 Generators pause execution using `yield`
 `.next()` controls execution step-by-step
 They remember state between calls
 Excellent for lazy evaluation and iteration
 Less common than `async/await`, but still very important to understand

