
### 29. Arrays: `sort`, `localeCompare`, and compare functions

---

# 29. Array Sorting in JavaScript (`sort`, `localeCompare`, compare functions)

---

# 1. The `sort()` Method — Default Behavior

### ✔ Definition

`Array.prototype.sort()` sorts the array in place, meaning the original array is modified.
By default, sorting is done lexicographically (dictionary/order of UTF-16 string values).

### ✔ Key Point

If you don’t provide a compare function:

 Every element is converted to a string
 Then sorted in dictionary order (not numerically)

### ✔ Example (VERY IMPORTANT)

```js
const nums = [1, 5, 20, 100, 3];
console.log(nums.sort()); 
// Output: [1, 100, 20, 3, 5]
```

### ✔ Why this happens?

Because "100" < "20" < "3" in string comparison.

### ✔ Conclusion

Never rely on default sort for numbers.

---

# 2. Sorting Numbers Properly (Using Compare Function)

To sort numbers correctly, you must use a compare function.

### ✔ Syntax

```js
array.sort((a, b) => a - b);
```

### ✔ Sorting Ascending

```js
const nums = [1, 5, 20, 100, 3];
console.log(nums.sort((a, b) => a - b));
// [1, 3, 5, 20, 100]
```

### ✔ Sorting Descending

```js
nums.sort((a, b) => b - a);
// [100, 20, 5, 3, 1]
```

### ✔ How compare function logically works

The function returns:

 Negative value → `a` comes before `b`
 Zero → order unchanged
 Positive value → `a` comes after `b`

Example:

```js
(a, b) => a - b
```

 If `a = 3`, `b = 10` → `3 - 10 = -7` → `3` comes before `10`
 If `a = 10`, `b = 3` → `10 - 3 = 7` → `10` comes after `3`

This produces ascending order.

---

# 3. Sorting Strings Properly (Using `localeCompare`)

### Problem with default sort for strings

Default sorting is fine for simple English words but fails when:

 Words have accents
 Words contain non-English alphabets
 You want case-insensitive sorting
 You want sorting for different languages

### ✔ Solution → `localeCompare()`

`localeCompare()` returns:

 Negative → string comes before compared string
 Zero → equal
 Positive → string comes after

### ✔ Using it in sort

```js
const names = ["Zebra", "apple", "Äpple", "áudio"];

names.sort((a, b) => a.localeCompare(b));
console.log(names);
```

### ✔ Why `localeCompare` is powerful?

It respects:

 Accents
 Case
 International character ordering
 Language-specific rules

---

# 4. Case-Insensitive Sorting

By default:

```js
["apple", "Zebra"].sort();
// ["Zebra", "apple"]
```

This is because uppercase letters are sorted before lowercase in UTF-16.

### ✔ Proper case-insensitive sort

```js
names.sort((a, b) => 
  a.toLowerCase().localeCompare(b.toLowerCase())
);
```

---

# 5. Sorting Objects Using Compare Functions

Often you need to sort by a specific object property.

### ✔ Example: Sort by age (ascending)

```js
const people = [
  { name: "Suyash", age: 23 },
  { name: "Aarav", age: 19 },
  { name: "Meera", age: 25 }
];

people.sort((a, b) => a.age - b.age);
```

### ✔ Sort by name (alphabetical)

```js
people.sort((a, b) => a.name.localeCompare(b.name));
```

---

# 6. Sorting Dates

Dates can be compared using timestamps:

```js
dates.sort((a, b) => new Date(a) - new Date(b));
```

---

# 7. Stable vs. Unstable Sort

### ✔ JavaScript sort was originally unstable.

Meaning: equal elements could appear in any order after sorting.

### ✔ Modern JavaScript (ES2019+) guarantees a stable sort

Example:

```js
const arr = [
  { score: 90, name: "A" },
  { score: 90, name: "B" }
];

arr.sort((a, b) => a.score - b.score);
// order will remain A then B
```

---

# 8. Sorting Complex Criteria (Multiple Conditions)

### ✔ Example: sort by score descending, ties by name ascending

```js
arr.sort((a, b) => {
  if (a.score !== b.score) return b.score - a.score;
  return a.name.localeCompare(b.name);
});
```

---

# 9. Sorting with Custom Rules

You can define ANY behavior inside compare function.

### ✔ Example: Place "Admin" first, others alphabetically

```js
users.sort((a, b) => {
  if (a.role === "Admin") return -1;
  if (b.role === "Admin") return 1;
  return a.name.localeCompare(b.name);
});
```

---

# 10. Performance Considerations

### ✔ Time Complexity

`sort` typically uses Timsort in modern engines:

 O(n log n) average and worst
 O(n) if array is mostly sorted

### ✔ In-place modification

Always remember:

```js
sort() mutates the array.
```

To avoid modifying original array:

```js
const sorted = [...arr].sort(...);
```

---

# 11. Sorting Mixed Types

Sorting arrays containing mixed types (numbers + strings) is confusing and should be avoided.

### Example:

```js
[10, "2", 5].sort();
// Output: ["10", "2", 5]
```

Everything is converted to string → messy order.

---

# 12. Summary Table

| Task                  | Best Method                                      |
| --------------------- | ------------------------------------------------ |
| Numeric ascending     | `(a, b) => a - b`                                |
| Numeric descending    | `(a, b) => b - a`                                |
| Alphabetical          | `a.localeCompare(b)`                             |
| Case-insensitive      | `a.toLowerCase().localeCompare(b.toLowerCase())` |
| Sort objects          | Compare object.prop                              |
| Multi-criteria        | Use if/else inside compare                       |
| Don’t mutate original | `sorted = [...arr].sort()`                       |

---

# 13. Interview-Level Tricks & Notes

### ✔ Trick 1: Sort without modifying original

```js
const sorted = [...arr].sort((a,b)=> a-b);
```

### ✔ Trick 2: Random shuffle (NOT recommended)

```js
arr.sort(() => Math.random() - 0.5);
```

(Not a uniform shuffle. Fisher–Yates is better.)

### ✔ Trick 3: Sort booleans

```js
arr.sort((a,b) => a - b);
```

`false` = 0, `true` = 1
So false rows come first.

### ✔ Trick 4: Sort by string length

```js
words.sort((a,b) => a.length - b.length);
```

---

# Final Summary

 `sort()` converts everything to string by default → never use it for numbers.
 Always use compare function for correct behavior.
 `localeCompare()` is best for sorting strings, names, and international text.
 Sorting objects is done by comparing a property.
 ES2019 guarantees stable sorting, which is crucial for chained sorts.
 Sorting modifies the original array—use spread to avoid mutation.

---


