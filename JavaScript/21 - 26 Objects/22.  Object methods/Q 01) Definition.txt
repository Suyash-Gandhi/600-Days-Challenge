
# ‚úÖ Object Methods in JavaScript (Complete Explanation)

Objects are one of the most fundamental building blocks in JavaScript. Along with storing data in key‚Äìvalue pairs, objects also contain functions, and when a function is stored inside an object, it is called an object method.

This topic is crucial for interviews because object methods are used everywhere ‚Äî classes, prototypes, modules, DOM manipulation, APIs, OOP systems, React state objects, etc.

---

# ‚≠ê 1. What Are Object Methods?

### Definition

An object method is simply a function stored as a property inside an object.

Example:

```js
const person = {
  name: "Alex",
  sayHello() {
    console.log(`Hello, I am ${this.name}`);
  }
};

person.sayHello(); // Hello, I am Alex
```

### Important Points:

 Methods help objects perform actions.
 `this` keyword inside methods refers to the owning object (most of the time).
 Methods make objects behave like entities with data + behavior (OOP concept).

---

# ‚≠ê 2. Different Ways to Define Object Methods

## (A) Regular Method Definition

The simplest and recommended way:

```js
const obj = {
  greet() {
    console.log("Hello!");
  }
};
```

## (B) Function Expression as Method

```js
const obj = {
  greet: function () {
    console.log("Hello!");
  }
};
```

## (C) Arrow Functions as Methods (‚ö† Not recommended)

```js
const obj = {
  greet: () => {
    console.log("Hello!");
  }
};
```

### ‚ùó Why arrow functions are bad as methods:

 Arrow functions do NOT have their own `this`.
 They take `this` from the surrounding scope (lexical scope).
 So they cannot properly refer to the object.

Example:

```js
const user = {
  name: "Tim",
  hello: () => {
    console.log(this.name); // undefined
  }
};

user.hello();
```

Use normal function methods when you need `this`.


# ‚≠ê 3. Important Built-in Object Methods in JavaScript

JavaScript gives many powerful object utility methods.

---

# üî∑ 3.1 Object.keys()

Returns an array of all keys.

```js
const obj = { a: 1, b: 2 };
console.log(Object.keys(obj)); // ["a", "b"]
```

Use case:

 Looping over object properties
 Validation
 Serialization

---

# üî∑ 3.2 Object.values()

Returns an array of values.

```js
console.log(Object.values(obj)); // [1, 2]
```

---

# üî∑ 3.3 Object.entries()

Returns an array of `[key, value]` pairs.

```js
console.log(Object.entries(obj)); 
// [["a",1], ["b",2]]
```

Useful for:

 Loops
 Converting to maps
 Converting to arrays

---

# üî∑ 3.4 Object.fromEntries()

Opposite of `entries()`

```js
const arr = [["x", 10], ["y", 20]];
console.log(Object.fromEntries(arr));
// { x: 10, y: 20 }
```

---

# üî∑ 3.5 Object.assign()

Copies properties from one object to another.

```js
const target = {};
const source = { a: 1, b: 2 };

Object.assign(target, source);
console.log(target); // { a: 1, b: 2 }
```

Use case:

 Cloning objects (shallow clone)
 Merging objects

---

# üî∑ 3.6 Object.freeze()

Makes an object immutable.

```js
const obj = { a: 1 };
Object.freeze(obj);
obj.a = 100; // ignored
```

---

# üî∑ 3.7 Object.seal()

Prevents adding/removing properties but allows modifying existing properties.

```js
const obj = { a: 1 };
Object.seal(obj);
obj.a = 50; // allowed
```

---

# üî∑ 3.8 Object.create()

Creates a new object using another object as prototype.

```js
const proto = { greet() { console.log("Hello"); }};
const obj = Object.create(proto);

obj.greet(); // Hello
```

This is the core of prototype-based inheritance.

---

# üî∑ 3.9 hasOwnProperty()

Checks if the property belongs to the object itself (not inherited).

```js
obj.hasOwnProperty("a");
```

---

# ‚≠ê 4. Getter and Setter Methods

Used to compute properties and protect data.

### Example:

```js
const user = {
  first: "Suyash",
  last: "Gandhi",
  
  get fullName() {
    return `${this.first} ${this.last}`;
  },

  set fullName(value) {
    const [f, l] = value.split(" ");
    this.first = f;
    this.last = l;
  }
};

console.log(user.fullName); // Suyash Gandhi
user.fullName = "Alex Rio";
console.log(user.fullName); // Alex Rio
```

### Why important?

 Helps create computed properties
 Data validation
 Encapsulation (OOP concept)

---

# ‚≠ê 6. Method Shorthand Syntax

Since ES6, you can write:

```js
const obj = {
  say() {
    return "hello";
  }
};
```

Instead of:

```js
const obj = {
  say: function() {
    return "hello";
  }
};
```

---

# ‚≠ê 6. Method Chaining

When methods return `this`, you can chain them:

```js
const calc = {
  x: 0,
  add(n) {
    this.x += n;
    return this;
  },
  multiply(n) {
    this.x = n;
    return this;
  }
};

calc.add(5).multiply(2).add(10);

console.log(calc.x); // 20
```

Used in:

 jQuery
 Express middleware
 Mongoose queries

---

# ‚≠ê 12. Adding Methods Dynamically

You can add methods after object creation.

```js
const obj = {};
obj.say = function() { console.log("Hello"); };
obj.say();
```

OR using `Object.defineProperty()`:

```js
Object.defineProperty(obj, "greet", {
  value() { console.log("Hi"); }
});
```

