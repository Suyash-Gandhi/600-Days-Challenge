

# üìå Property Descriptors & `Object.defineProperty()` ‚Äî Complete Explanation

Property descriptors are one of the most powerful but least understood features in JavaScript. They allow developers to precisely control the behavior of object properties ‚Äî including whether they can be changed, deleted, enumerated, or whether they trigger getter/setter functions.

These controls are the backbone of frameworks, libraries, immutability utilities, and internal JavaScript behaviors.

---

# 1Ô∏è‚É£ What Is a Property Descriptor?

A property descriptor is a metadata object that describes how a property behaves.

JavaScript has two kinds of property descriptors:

## A. Data Descriptors

These describe a normal value property.

They include:

 `value`
 `writable`
 `enumerable`
 `configurable`

## B. Accessor Descriptors

These describe a property defined via a getter/setter.

They include:

 `get`
 `set`
 `enumerable`
 `configurable`

A property must be either a data descriptor or an accessor descriptor ‚Äî not both.

---

# 2Ô∏è‚É£ Syntax of `Object.defineProperty()`

```js
Object.defineProperty(obj, 'key', {
  // descriptor goes here
});
```

Example:

```js
const person = {};
Object.defineProperty(person, 'name', {
  value: 'Suyash',
  writable: false,
  enumerable: true,
  configurable: false
});
```

---

# 3Ô∏è‚É£ Default Values of All Descriptors (VERY IMPORTANT)

When defining a property with `Object.defineProperty`, ALL unspecified fields default to `false`.

| Descriptor     | Default     |
| -------------- | ----------- |
| `value`        | `undefined` |
| `writable`     | false   |
| `enumerable`   | false   |
| `configurable` | false   |
| `get`          | `undefined` |
| `set`          | `undefined` |

‚û°Ô∏è This is why people get unexpected behavior.

Example:

```js
const obj = {};
Object.defineProperty(obj, 'x', { value: 10 });
```

Here:

 `x` is not writable
 `x` is not enumerable
 `x` is not configurable

---

# 4Ô∏è‚É£ Data Descriptor Explained

A data descriptor has:

1. value ‚Äì the stored value.
2. writable ‚Äì whether the value can be changed.
3. enumerable ‚Äì whether it appears in loops.
4. configurable ‚Äì whether the descriptor itself can be changed or property deleted.

Example:

```js
const user = {};
Object.defineProperty(user, 'id', {
  value: 101,
  writable: false,
  enumerable: true,
  configurable: false
});
```

### Effects:

 `user.id = 200` ‚Üí ignored or error in strict mode
 `for (let k in user)` ‚Üí `id` appears (enumerable = true)
 `delete user.id` ‚Üí fails because configurable = false
 Cannot change its descriptor again.

---

# 5Ô∏è‚É£ Accessor Descriptor (getters & setters)

Accessor descriptors use functions rather than stored values.

```js
const user = { _age: 20 };

Object.defineProperty(user, 'age', {
  get() { return this._age; },
  set(v) { this._age = v; },
  enumerable: true,
  configurable: true
});
```

### Effects:

 Accessing `user.age` calls the `get()` function.
 Updating `user.age = 25` calls the `set()` function.
 Value is internally stored in `_age`.

---

# 6Ô∏è‚É£ Why Data Descriptor vs Accessor Descriptor Cannot Mix?

Because descriptors define property types.
You cannot have both:

 `value` and `get`
 `writable` and `set`
 etc.

If you try:

```js
Object.defineProperty(obj, 'x', {
  value: 10,
  get() { return 20; }
});
```

‚û°Ô∏è ‚ùå Error: Cannot have both value and getter/setter.

---

# 7Ô∏è‚É£ Using `Object.getOwnPropertyDescriptor()`

You can inspect descriptor properties:

```js
const obj = { name: 'JavaScript' };
console.log(Object.getOwnPropertyDescriptor(obj, 'name'));
```

Output:

```js
{
  value: 'JavaScript',
  writable: true,
  enumerable: true,
  configurable: true
}
```

---

# 8Ô∏è‚É£ Detailed Explanation of All Descriptor Attributes

Let‚Äôs explain each attribute with examples.

---

## A. writable

Determines if the value can be changed.

```js
Object.defineProperty(obj, 'x', {
  value: 50,
  writable: false
});

obj.x = 100;
console.log(obj.x); // still 50
```

Strict mode throws an error.

---

## B. enumerable

Controls visibility in loops.

```js
const obj = {};
Object.defineProperty(obj, 'secret', {
  value: 'hidden',
  enumerable: false
});
```

Now:

 `for‚Ä¶in` ‚Üí skips it
 `Object.keys()` ‚Üí skips it
 `JSON.stringify()` ‚Üí skips it

But:

```js
obj.secret // accessible
```

---

## C. configurable

The most powerful one.

If `configurable = false`:

 You cannot delete the property.
 You cannot redefine it using `Object.defineProperty`.
 You cannot convert data ‚Üí accessor or vice versa.

This is how built-ins like `Math.PI` are protected.

Example:

```js
console.log(Object.getOwnPropertyDescriptor(Math, 'PI'));
```

Output:

```js
{
  value: 3.141592653589793,
  writable: false,
  enumerable: false,
  configurable: false
}
```

You cannot change or delete `Math.PI`.

---

# 9Ô∏è‚É£ Freezing with Property Descriptors

Immutability utilities (`freeze`, `seal`) use descriptors internally.

---

## A. `Object.freeze()`

 Makes all properties non-writable
 Makes all properties non-configurable
 Does NOT make them non-enumerable

---

## B. `Object.seal()`

 Only makes them non-configurable
 Does NOT touch writable or enumerable flags

---

# üîü Practical Use-Cases of Property Descriptors

### 1. Creating immutable constants

```js
Object.defineProperty(obj, 'API_KEY', {
  value: 'SECRET',
  writable: false,
  configurable: false
});
```

---

### 2. Hiding internal properties

```js
Object.defineProperty(obj, '_id', {
  value: 100,
  enumerable: false
});
```

---

### 3. Creating computed properties (like in frameworks)

```js
Object.defineProperty(obj, 'fullName', {
  get() { return `${this.fname} ${this.lname}`; }
});
```

---

### 4. Validating inputs using setters

```js
Object.defineProperty(user, 'age', {
  set(v) {
    if (v < 0) throw new Error('Invalid age!');
    this._age = v;
  }
});
```

---

### 5. Making logs on property access

```js
Object.defineProperty(obj, 'data', {
  get() {
    console.log('Accessed!');
    return this._data;
  }
});
```

This is how Vue 2 implements reactivity.

---

### 6. Framework-level magic like Angular, Vue, Ember

They use descriptors to:

 detect changes
 create watchers
 intercept property access
 create hidden internal properties

---
