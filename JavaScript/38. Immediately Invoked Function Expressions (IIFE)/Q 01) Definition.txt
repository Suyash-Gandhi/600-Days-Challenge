## 38. Immediately Invoked Function Expressions (IIFE)

An Immediately Invoked Function Expression (IIFE) is a JavaScript function that is defined and executed immediately after it is created.
It is mainly used to create a private scope, so variables do not leak into the global namespace.

---

### 1. Why IIFE exists (the core problem it solves)

Before modern JavaScript features like `let`, `const`, and ES modules, all `var` variables were function-scoped, not block-scoped.

This caused:

 Global namespace pollution
 Variable name collisions
 Accidental overwriting of values

IIFE was introduced as a pattern to simulate private scope.

---

### 2. Basic syntax of an IIFE

An IIFE is a function expression, not a declaration.

```js
(function () {
  // code here
})();
```

OR (also very common):

```js
(() => {
  // code here
})();
```

ðŸ”¹ The first parentheses turn the function into an expression
ðŸ”¹ The second parentheses execute the function immediately

---

### 3. Why parentheses are mandatory

This will NOT work:

```js
function test() {
  console.log("Hello");
}();
```

Because JavaScript treats this as a function declaration, not an expression.

Wrapping it in parentheses forces JavaScript to treat it as an expression, which can then be executed immediately.

---

### 4. IIFE with parameters

IIFEs can accept arguments like normal functions.

```js
((name) => {
  console.log(`Hello ${name}`);
})("Suyash");
```

âœ… Useful when you want to:

 Pass configuration values
 Inject dependencies
 Avoid using globals

---

### 5. Return values from IIFE

An IIFE can return a value and store it in a variable.

```js
const result = (() => {
  const a = 10;
  const b = 20;
  return a + b;
})();

console.log(result); // 30
```

This is powerful for initialization logic.

---

### 6. Real-world use cases of IIFE

#### 6.1 Avoiding global scope pollution

```js
(() => {
  const secretKey = "123-SECRET";
  console.log("Initialized securely");
})();
```

`secretKey` is not accessible outside.

---

#### 6.2 Module-like pattern (pre-ES6)

```js
const counter = (() => {
  let count = 0;

  return {
    increment: () => ++count,
    decrement: () => --count,
    getCount: () => count
  };
})();

counter.increment();
counter.increment();
console.log(counter.getCount()); // 2
```

âœ” `count` is private
âœ” Only controlled access is exposed

---

#### 6.3 One-time initialization logic

```js
(() => {
  console.log("App initialized");
  // setup listeners
  // preload data
})();
```

This code runs once and never again.

---

### 7. IIFE vs normal function

| Feature                   | IIFE   | Normal Function |
| ------------------------- | ------ | --------------- |
| Executes immediately      | âœ… Yes  | âŒ No            |
| Creates private scope     | âœ… Yes  | âŒ Depends       |
| Reusable                  | âŒ No   | âœ… Yes           |
| Useful for initialization | âœ… Very | âŒ Less          |

---

### 8. IIFE in modern JavaScript (important perspective)

In modern JS, IIFEs are less common because we now have:

 `let` and `const` (block scope)
 ES modules (`import` / `export`)
 Bundlers and module systems

Example replacing IIFE with block scope:

```js
{
  const value = 42;
}
```

Still, IIFE is important because:

 You will see it in legacy code
 Many libraries still use it internally
 It explains why modern scoping exists

---

### 9. Common mistakes with IIFE

âŒ Forgetting parentheses
âŒ Trying to reuse an IIFE
âŒ Overusing IIFE when `let` / modules are enough

---

### 10. When should YOU use IIFE today?

Use IIFE when:

 You need one-time execution
 You want strict isolation
 Youâ€™re writing library-level or legacy-compatible code

Avoid IIFE when:

 ES modules are available
 Simple block scoping is sufficient

---

### One-line summary

> An IIFE is a function that runs immediately to create a private scope and prevent global variable pollution.

If you want, next we can cover:

 IIFE vs ES Modules (deep comparison)
 How bundlers internally use IIFE
 Interview questions around IIFE
