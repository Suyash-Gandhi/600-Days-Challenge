
# 32. Sets and Maps in JavaScript (Full Explanation + Examples)

# 1. What is a Set?

A Set is an ordered collection of unique values.
It ensures that no duplicate entries exist.

### Key characteristics

 Stores unique values
 Can store primitive values or objects
 Maintains insertion order
 Has efficient lookup using internal hash structure
 Does not support direct indexing (like `set[0]`)

---

## 1.1 Creating a Set

```js
const numbers = new Set([1, 2, 3, 3, 4]);
console.log(numbers); // Set { 1, 2, 3, 4 }
```

Duplicate 3 is automatically removed.

---

## 1.2 Set Methods

### add(value)

Adds an item.

```js
const set = new Set();
set.add(10).add(20).add(10);
console.log(set);  // Set { 10, 20 }
```

---

### delete(value)

Removes an element.

```js
set.delete(20);
```

---

### has(value)

Checks if a value exists.

```js
set.has(10); // true
```

---

### clear()

```js
set.clear();
```

---

### size

```js
set.size; // number of elements
```

---

# 1.3 Iterating Over a Set

You can loop using:

### for...of

```js
for (const val of numbers) {
  console.log(val);
}
```

---

### forEach

```js
numbers.forEach(v => console.log(v));
```

---

# 1.4 Use Cases of Set

### 1. Removing duplicates

```js
const arr = [1, 2, 2, 3, 4];
const unique = [...new Set(arr)];
console.log(unique); // [1, 2, 3, 4]
```

---

### 2. Efficient existence check

Much faster than searching arrays (`includes` has O(n) time, while `Set.has` is O(1)).

---

### 3. Tracking unique events

Example: storing unique IDs, visited pages, logged users.

---

### 4. Performing Set operations

JavaScript does not provide built-ins, but you can implement:

#### Union

```js
const union = new Set([...a, ...b]);
```

#### Intersection

```js
const intersection = new Set([...a].filter(x => b.has(x)));
```

#### Difference

```js
const difference = new Set([...a].filter(x => !b.has(x)));
```

---

# 2. What is a Map?

A Map is a collection of key–value pairs where keys can be any type, including objects.

This is major advantage over plain objects, which only allow:

 strings
 symbols

Maps internally use a hash table, giving:

 predictable iteration order
 faster lookups
 no prototype key collision

---

## 2.1 Creating a Map

```js
const map = new Map([
  ["name", "Suyash"],
  ["age", 22]
]);
```

---

## 2.2 Map Methods

### set(key, value)

```js
map.set("country", "India");
map.set({ id: 1 }, "UserData");
```

Yes, objects can be keys — unlike in normal objects.

---

### get(key)

```js
map.get("name"); // "Suyash"
```

---

### has(key)

```js
map.has("age"); // true
```

---

### delete(key)

Removes key–value pair.

---

### clear()

Empties the map.

---

### size

```js
map.size;
```

---

# 2.3 Iterating Over Maps

### for...of (entries)

```js
for (const [key, value] of map) {
  console.log(key, value);
}
```

---

### keys()

```js
for (const key of map.keys()) console.log(key);
```

---

### values()

```js
for (const value of map.values()) console.log(value);
```

---

### forEach

```js
map.forEach((value, key) => console.log(key, value));
```

---

# 2.4 Use Cases of Map

### 1. Storing data with object keys

```js
const user = { id: 1 };
const visitCount = new Map();

visitCount.set(user, 5);
```

You cannot do this with normal objects.

---

### 2. Creating caches

Map is perfect for memoization.

```js
const cache = new Map();

const fib = n => {
  if (cache.has(n)) return cache.get(n);
  if (n < 2) return n;

  const result = fib(n-1) + fib(n-2);
  cache.set(n, result);
  return result;
};
```

---

### 3. Maintaining insertion order

Great for:

 LRU cache
 Routing tables
 Config maps

---

### 4. Fast lookups vs Objects

 `Map.get()` is faster than `obj[key]`
 Objects have prototype pollution issues
 Map is designed purely for key–value storage, so more optimized

---

# 3. Difference Between Set and Map

| Feature    | Set                           | Map                                    |
| ---------- | ----------------------------- | -------------------------------------- |
| Structure  | Only values                   | Key–value pairs                        |
| Uniqueness | Unique values                 | Unique keys                            |
| Access     | `has()`                       | `get()`, `set()`, `has()`              |
| Order      | Insertion order               | Insertion order                        |
| Key Type   | Not applicable                | Any type (object, function, primitive) |
| Use Cases  | Unique list, membership check | Dictionaries, caches, metadata         |

---

# 4. Difference Between Map and Object

| Feature     | Map                                       | Object                            |
| ----------- | ----------------------------------------- | --------------------------------- |
| Key Type    | Any type                                  | String or symbol only             |
| Order       | Maintains insertion order                 | Not guaranteed before ES6         |
| Size        | `map.size`                                | manually count                    |
| Iteration   | Easy with `for..of`, `keys()`, `values()` | Hard, must use `Object.keys` etc  |
| Performance | Optimized for frequent insert/remove      | Not optimized for such operations |
| Usefulness  | When keys are dynamic                     | When structure is static          |

---

# 5. WeakSet and WeakMap

These are memory-optimized versions.

---

## 5.1 WeakSet

 Stores only objects, no primitives
 Objects are held weakly, meaning if no other reference exists, they are garbage-collected
 No size property
 Not iterable

Best for storing:

 temporary references
 private object lists

Example:

```js
const ws = new WeakSet();
let obj = { a: 1 };
ws.add(obj);

obj = null; // object removed automatically
```

---

## 5.2 WeakMap

 Keys must be objects
 Values can be anything
 Keys garbage-collect when there are no strong references
 Not iterable
 Used for private data in classes

Example:

```js
const privateData = new WeakMap();

class User {
  constructor(name, salary) {
    privateData.set(this, { salary });
    this.name = name;
  }

  getSalary() {
    return privateData.get(this).salary;
  }
}

const u = new User("Suyash", 50000);
```

No one can access salary from outside.

---

# 6. Performance Comparison

### When to use Set

 Need fast lookups
 Ensuring uniqueness
 Removing duplicates from arrays
 Implementing mathematical sets

### When to use Map

 Dynamic key–value pairs
 Keys are not fixed
 Keys can be objects
 Large number of insertions/deletions

### When to NOT use objects

 When order matters
 When keys are dynamic
 When keys are not strings
 When performance is important

---

# 7. Real-World Examples (Important for Interviews)

### 1. Counting unique visitors

```js
const visitors = new Set();

function trackVisit(userId) {
  visitors.add(userId);
}
```

---

### 2. Tag suggestions using Sets

```js
const tags = new Set(["js", "react", "node"]);
tags.add("node"); // ignored
```

---

### 3. Storing metadata using Maps

```js
const meta = new Map();
meta.set("version", "1.0.0");
meta.set("author", "Suyash");
```

---

### 4. Router path → handler mapping (Map)

```js
const routes = new Map();
routes.set("/home", () => console.log("Home"));
routes.set("/about", () => console.log("About"));
```

---

### 5. Event listener registry (Map)

```js
const eventMap = new Map();

eventMap.set("click", handlerFn);
```

---


