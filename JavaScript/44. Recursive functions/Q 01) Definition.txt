## 44. Recursive Functions (JavaScript)

A **recursive function** is a function that **calls itself** in order to solve a problem.
The key idea is to break a big problem into **smaller versions of the same problem**, until a simple case can be solved directly.

---

## 1. Core Components of Recursion

Every recursive function **must** have two things:

### 1. Base Case

* The condition where the function **stops calling itself**
* Prevents infinite recursion

### 2. Recursive Case

* The part where the function **calls itself**
* Moves the problem closer to the base case

> **Rule of thumb:**
> If your recursion doesnâ€™t clearly reach the base case, itâ€™s wrong.

---

## 2. Simple Example: Factorial

Mathematically:

```
factorial(n) = n Ã— factorial(n - 1)
factorial(0) = 1
```

JavaScript:

```js
const factorial = (n) => {
  if (n === 0) return 1;      // base case
  return n * factorial(n - 1); // recursive case
};
```

**How it works internally (factorial(3)):**

```
factorial(3)
â†’ 3 * factorial(2)
â†’ 3 * (2 * factorial(1))
â†’ 3 * (2 * (1 * factorial(0)))
â†’ 3 * 2 * 1 * 1
```

---

## 3. Call Stack Explained (Very Important)

Each recursive call is pushed onto the **call stack**.

Example:

```js
const countDown = (n) => {
  if (n === 0) return;
  console.log(n);
  countDown(n - 1);
};
```

Call stack behavior:

```
countDown(3)
countDown(2)
countDown(1)
countDown(0)
```

Then the stack **unwinds** back up.

âš ï¸ **Too many recursive calls = stack overflow error**

---

## 4. Common Use Cases of Recursion

Recursion is especially useful when dealing with **self-similar structures**:

### a) Tree & Graph Traversal

* DOM traversal
* File systems
* Blockchain Merkle trees

### b) Divide & Conquer Algorithms

* Binary search
* Merge sort
* Quick sort

### c) Nested Data Structures

* JSON parsing
* Deep object traversal

Example (sum of nested array):

```js
const deepSum = (arr) => {
  let sum = 0;

  for (const item of arr) {
    if (Array.isArray(item)) {
      sum += deepSum(item);
    } else {
      sum += item;
    }
  }

  return sum;
};
```

---

## 5. Recursion vs Loop (Very Important Comparison)

| Aspect      | Recursion               | Loop            |
| ----------- | ----------------------- | --------------- |
| Readability | Often cleaner           | Often simpler   |
| Performance | Slower (stack overhead) | Faster          |
| Memory      | Uses call stack         | Constant memory |
| Risk        | Stack overflow          | Safer           |

ðŸ‘‰ **Industry rule:**
If iteration is simple â†’ use a loop
If structure is recursive â†’ use recursion

---

## 6. Tail Recursion (Optimization Concept)

A function is **tail recursive** if the recursive call is the **last operation**.

```js
const factorial = (n, acc = 1) => {
  if (n === 0) return acc;
  return factorial(n - 1, acc * n);
};
```

### Important Reality Check

* JavaScript **does not reliably optimize tail calls**
* Browsers mostly **ignore Tail Call Optimization (TCO)**

So:

> Tail recursion is conceptually good, but **donâ€™t rely on it in JS interviews or production**

---

## 7. Common Mistakes in Recursion

### âŒ Missing base case

```js
const bad = (n) => bad(n - 1); // infinite recursion
```

### âŒ Base case never reached

```js
const wrong = (n) => {
  if (n === 0) return;
  wrong(n + 1); // moves away from base case
};
```

### âŒ Mutating shared data

* Leads to hard-to-debug issues
* Prefer pure recursion when possible

---

## 8. When NOT to Use Recursion

Avoid recursion when:

* Depth is very large (e.g. 1e6)
* Performance is critical
* A loop is clearer and safer

Example better with loop:

```js
const sum = (n) => {
  let total = 0;
  for (let i = 1; i <= n; i++) {
    total += i;
  }
  return total;
};
```

---

## 9. Recursion in Interviews (How to Think)

Interviewers look for:

1. Clear base case
2. Correct reduction step
3. Understanding of stack behavior
4. Ability to convert recursion â†” iteration

Typical questions:

* Reverse a string recursively
* Fibonacci (with memoization)
* Tree traversal
* Flatten nested arrays

---

## 10. One-Line Mental Model

> **Recursion = trust the function to solve smaller versions of the same problem**

If you want, next we can cover:

* Recursive vs iterative conversion
* Recursion + memoization
* Real-world recursion in React & DOM
* Why Fibonacci recursion is bad without memoization
