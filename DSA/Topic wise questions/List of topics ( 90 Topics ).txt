
# ðŸ“Š DSA Interview Master List (85â€“90 Topics)

---

1. Basics & Foundations (Junior Level)

1. Time & space complexity â€“ Big O, Big Î˜, Big Î©
2. Recursion â€“ basics, stack overflow, tail recursion
3. Iterative vs recursive solutions
4. Divide & conquer strategy
5. Sorting algorithms: Bubble, Selection, Insertion
6. Sorting algorithms: Merge Sort, Quick Sort
7. Sorting algorithms: Heap Sort
8. Sorting stability & in-place vs out-of-place sorting
9. Searching algorithms: Linear search
10. Searching algorithms: Binary search (iterative & recursive)
11. Binary search applications (finding boundaries, ceil/floor)
12. Two-pointer technique (arrays & strings)
13. Sliding window technique (fixed & variable size)
14. Prefix sum arrays & cumulative sums
15. Hashing basics (hash tables & collision handling)

---

2. Arrays & Strings

16. Array basics (insertion, deletion, traversal)
17. Multi-dimensional arrays & matrices
18. Common array problems (max/min, sum, subarray problems)
19. Kadaneâ€™s algorithm (maximum subarray sum)
20. Rotate array & reverse array problems
21. Dutch National Flag problem
22. Merge intervals problem
23. Two-sum & 3-sum problems
24. Subarray with given sum problem
25. Strings â€“ palindrome check, reverse, substring search
26. Anagram & permutation problems
27. Pattern matching (naive & KMP algorithm)
28. Longest common prefix / longest common substring
29. Character frequency counting problems
30. String compression & encoding problems

---

3. Linked Lists

31. Singly linked list â€“ insertion, deletion, traversal
32. Doubly linked list â€“ insertion, deletion, traversal
33. Circular linked list basics
34. Reversing a linked list (iterative & recursive)
35. Detecting cycle in linked list (Floydâ€™s Tortoise & Hare)
36. Finding middle node & kth node from end
37. Merge two sorted linked lists
38. Remove duplicates from sorted/unsorted linked list
39. Linked list intersection point
40. Flattening linked lists / multi-level linked list

---

4. Stacks & Queues

41. Stack implementation (array & linked list)
42. Queue implementation (array & linked list)
43. Deque & double-ended queue
44. Circular queue
45. Stack applications â€“ balanced parentheses, next greater element
46. Queue applications â€“ sliding window max, BFS
47. Priority Queue / Heap basics
48. Monotonic stack / monotonic queue
49. Implement stack using queues & queue using stacks
50. Min stack / Max stack problems

---

5. Trees & Graphs

51. Binary Tree basics â€“ traversal (inorder, preorder, postorder)
52. Binary Search Tree (BST) properties & operations
53. Balanced trees â€“ AVL, Red-Black tree basics
54. Tree problems â€“ height, diameter, path sum
55. Lowest Common Ancestor (LCA) in BST & Binary Tree
56. Trie / Prefix tree â€“ insert, search, delete
57. Graph representation â€“ adjacency list/matrix
58. Graph traversal â€“ BFS, DFS (recursive & iterative)
59. Topological sort (DFS & Kahnâ€™s algorithm)
60. Detect cycle in directed & undirected graphs
61. Shortest path algorithms â€“ Dijkstra, Bellman-Ford
62. Minimum spanning tree â€“ Primâ€™s & Kruskalâ€™s
63. Connected components & strongly connected components (Kosaraju, Tarjan)
64. Graph applications â€“ bipartite check, islands count

---

6. Heaps & Advanced Data Structures

65. Heap basics â€“ min-heap, max-heap
66. Heap operations â€“ insert, extract-min/max
67. Heap applications â€“ priority queues, heap sort
68. Segment tree basics â€“ sum & min/max queries
69. Lazy propagation in segment trees
70. Fenwick Tree / Binary Indexed Tree
71. Disjoint Set Union (Union-Find) â€“ path compression & union by rank
72. Sparse table â€“ range minimum queries

---

7. Algorithms & Patterns (Intermediate â†’ Advanced)

73. Recursion & backtracking problems â€“ N-Queens, Sudoku
74. Subset / combination / permutation generation
75. Dynamic programming â€“ Fibonacci, Knapsack, Coin Change
76. Longest Common Subsequence / Longest Increasing Subsequence
77. Matrix DP problems (unique paths, min path sum)
78. DP on trees & graphs
79. Greedy algorithms â€“ activity selection, interval scheduling
80. Bit manipulation techniques (XOR, shifting, masks)
81. Sliding window & two-pointer pattern problems
82. Divide & conquer pattern problems (max subarray, closest pair)

---

8. Advanced & System Design Related DSA

83. Advanced graph algorithms â€“ network flow, Edmonds-Karp
84. Advanced string algorithms â€“ Rabin-Karp, Z-algorithm
85. Advanced tree algorithms â€“ heavy-light decomposition
86. LRU / LFU cache implementation
87. Circular buffer / deque problems
88. Memory-efficient data structures â€“ tries, bloom filters
89. Union of intervals / sweep line problems
90. Advanced DP problems â€“ DP with bitmask, DP on subsets

---
